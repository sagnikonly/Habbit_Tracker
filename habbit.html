<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Habit Tracker</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    <style>
        :root {
            --primary: #4361ee;
            --primary-light: #4895ef;
            --secondary: #3f37c9;
            --accent: #f72585;
            --light: #f8f9fa;
            --dark: #212529;
            --success: #4cc9f0;
            --warning: #fca311;
            --danger: #e63946;
            --bg-gradient: linear-gradient(135deg, #4361ee, #3a0ca3);
            --card-bg: rgba(255, 255, 255, 0.9);
            --card-shadow: 0 8px 32px rgba(31, 38, 135, 0.2);
        }

        /* Theme: Ocean */
        .theme-ocean {
            --primary: #0077b6;
            --primary-light: #00b4d8;
            --secondary: #0096c7;
            --accent: #03045e;
            --success: #48cae4;
            --warning: #ffb703;
            --danger: #e63946;
            --bg-gradient: linear-gradient(135deg, #0077b6, #03045e);
        }

        /* Theme: Forest */
        .theme-forest {
            --primary: #2d6a4f;
            --primary-light: #40916c;
            --secondary: #1b4332;
            --accent: #d8f3dc;
            --success: #52b788;
            --warning: #ffb700;
            --danger: #d62828;
            --bg-gradient: linear-gradient(135deg, #2d6a4f, #1b4332);
        }

        /* Theme: Sunset */
        .theme-sunset {
            --primary: #7209b7;
            --primary-light: #9d4edd;
            --secondary: #560bad;
            --accent: #f72585;
            --success: #4cc9f0;
            --warning: #fca311;
            --danger: #d00000;
            --bg-gradient: linear-gradient(135deg, #7209b7, #3a0ca3);
        }

        /* Theme: Dark */
        .theme-dark {
            --primary: #4cc9f0;
            --primary-light: #4895ef;
            --secondary: #4361ee;
            --accent: #f72585;
            --light: #e0e1dd;
            --dark: #f8f9fa;
            --success: #52b788;
            --warning: #fca311;
            --danger: #e63946;
            --bg-gradient: linear-gradient(135deg, #1b263b, #0d1b2a);
            --card-bg: rgba(34, 40, 49, 0.9);
            --card-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
            color: var(--light);
        }

        /* Font settings */
        .font-sans {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        .font-serif {
            font-family: Georgia, 'Times New Roman', Times, serif;
        }

        .font-mono {
            font-family: 'Courier New', Courier, monospace;
        }

        /* Settings button */
        .settings-btn {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: var(--primary);
            color: white;
            border: none;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.5rem;
            cursor: pointer;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
            z-index: 999;
            transition: transform 0.3s, background 0.3s;
        }

        .settings-btn:hover {
            transform: scale(1.1);
            background: var(--secondary);
        }

        /* Settings panel */
        .settings-panel {
            position: fixed;
            top: 0;
            right: -350px;
            width: 350px;
            height: 100%;
            background: var(--card-bg);
            box-shadow: -5px 0 15px rgba(0, 0, 0, 0.2);
            z-index: 1000;
            padding: 20px;
            overflow-y: auto;
            transition: right 0.3s ease;
        }

        .settings-panel.open {
            right: 0;
        }

        .settings-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            padding-bottom: 10px;
        }

        .settings-title {
            font-size: 1.5rem;
            font-weight: 600;
            color: var(--primary);
        }

        .close-settings {
            background: none;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            color: var(--dark);
        }

        .settings-section {
            margin-bottom: 20px;
        }

        .settings-section-title {
            font-size: 1.2rem;
            font-weight: 600;
            margin-bottom: 10px;
            color: var(--primary);
        }

        .theme-selector {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }

        .theme-option {
            height: 60px;
            border-radius: 10px;
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            font-weight: 500;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .theme-option:hover {
            transform: scale(1.05);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }

        .theme-option.active {
            border: 3px solid white;
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
        }

        .theme-default {
            background: linear-gradient(135deg, #4361ee, #3a0ca3);
        }

        .theme-ocean {
            background: linear-gradient(135deg, #0077b6, #03045e);
        }

        .theme-forest {
            background: linear-gradient(135deg, #2d6a4f, #1b4332);
        }

        .theme-sunset {
            background: linear-gradient(135deg, #7209b7, #3a0ca3);
        }

        .theme-dark {
            background: linear-gradient(135deg, #1b263b, #0d1b2a);
        }

        .font-selector {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }

        .font-option {
            padding: 8px 15px;
            border-radius: 20px;
            cursor: pointer;
            background: rgba(255, 255, 255, 0.1);
            transition: background 0.2s;
        }

        .font-option:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .font-option.active {
            background: var(--primary);
            color: white;
        }

        .settings-toggle {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 50px;
            height: 24px;
        }

        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 24px;
        }

        .toggle-slider:before {
            position: absolute;
            content: "";
            height: 16px;
            width: 16px;
            left: 4px;
            bottom: 4px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }

        input:checked + .toggle-slider {
            background-color: var(--primary);
        }

        input:checked + .toggle-slider:before {
            transform: translateX(26px);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        body {
            background: var(--bg-gradient);
            color: var(--dark);
            min-height: 100vh;
            padding: 20px;
            margin: 0;
            overflow-x: hidden;
        }

        .app-container {
            max-width: 100%;
            margin: 0 auto;
            display: grid;
            grid-template-columns: 1fr;
            gap: 20px;
        }

        @media (min-width: 992px) {
            .app-container {
                grid-template-columns: 1fr 1fr 1fr; /* Change to 3 columns layout */
                grid-template-areas: 
                    "header header header"
                    "goals motivation leaderboard"
                    "goals stats leaderboard"
                    "actions actions actions"
                    "custom custom custom";
            }
            
            .header {
                grid-area: header;
            }
            
            .goals-section {
                grid-area: goals;
            }
            
            .motivation-section {
                grid-area: motivation;
            }
            
            .stats-section {
                grid-area: leaderboard;
            }
            
            .graph-section {
                grid-area: stats;
            }
            
            .daily-actions {
                grid-area: actions;
            }
            
            .customization-container {
                grid-area: custom;
            }
        }

        /* New layout adjustments for full width */
        .full-width-section {
            grid-column: 1 / -1;
            width: 100%;
        }

        .customization-container {
            grid-column: 1 / -1;
            display: flex;
            flex-direction: column;
            gap: 20px;
            margin-top: 20px;
        }

        .customization-section {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
        }

        /* Make cards more visually appealing */
        .card {
            background: var(--card-bg);
            border-radius: 15px;
            box-shadow: var(--card-shadow);
            padding: 20px;
            backdrop-filter: blur(10px);
            transition: transform 0.3s, box-shadow 0.3s;
            height: 100%; /* Ensure all cards have the same height in their row */
            display: flex;
            flex-direction: column;
        }

        .card:hover {
            transform: translateY(-5px);
            box-shadow: 0 12px 40px rgba(31, 38, 135, 0.3);
        }

        .card .section-title {
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }

        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            grid-column: 1 / -1;
            background: var(--card-bg);
            border-radius: 15px;
            padding: 20px;
            box-shadow: var(--card-shadow);
            /* Removed sticky positioning */
            position: relative;
            z-index: 10;
        }

        .header h1 {
            font-size: 2rem;
            font-weight: 700;
            color: var(--primary);
            display: flex;
            align-items: center;
        }

        .header h1 i {
            margin-right: 10px;
            color: var(--accent);
        }

        .user-stats {
            display: flex;
            gap: 15px; /* Make all gaps between elements consistent */
            align-items: center;
            flex-wrap: wrap;
            justify-content: flex-end;
        }

        /* Container specifically for the header buttons to ensure consistent alignment */
        .header .user-stats {
            display: flex;
            align-items: center;
            flex-wrap: nowrap; /* Prevent wrapping to keep buttons in a single row */
            gap: 15px; /* Consistent spacing between all elements */
        }

        /* Header buttons consistent styling */
        .user-stats .btn, .user-stats .stat-box {
            min-width: 140px;
            height: 42px;
            margin: 0;
            padding: 0 15px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            transition: transform 0.2s, box-shadow 0.2s, background-color 0.2s;
            font-weight: 600;
        }

        .user-stats .btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 6px 15px rgba(0, 0, 0, 0.2);
        }

        .user-stats .btn i {
            font-size: 1rem;
        }

        @media (max-width: 768px) {
            .user-stats {
                flex-direction: column;
                align-items: stretch;
            }
            
            .user-stats .stat-box,
            .user-stats .btn {
                width: 100%;
                margin-bottom: 8px;
            }
            
            /* Improved responsive behavior for header buttons */
            .header {
                flex-direction: column;
                padding: 15px;
            }
            
            .header h1 {
                margin-bottom: 15px;
                font-size: 1.8rem;
                text-align: center;
            }
            
            .user-stats {
                display: grid;
                grid-template-columns: 1fr 1fr;
                width: 100%;
                gap: 8px;
            }
            
            .header .user-stats {
                flex-wrap: wrap; /* Allow wrapping on small screens */
            }
            
            .user-stats .btn, .user-stats .stat-box {
                font-size: 0.8rem;
                padding: 8px 5px;
                text-align: center;
                display: flex;
                align-items: center;
                justify-content: center;
                margin: 0;
                min-width: 0; /* Allow buttons to be smaller on mobile */
                height: 38px; /* Slightly smaller height on mobile */
            }
            
            .user-stats .btn i, .user-stats .stat-box i {
                margin-right: 4px;
                font-size: 0.9em;
            }
        }

        .stat-box {
            background: linear-gradient(135deg, var(--primary-light), var(--primary));
            color: white;
            padding: 10px 15px;
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center; /* Center content like buttons */
            gap: 10px;
            font-weight: 600;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            transition: transform 0.2s, box-shadow 0.2s;
            height: 42px; /* Match button height */
            min-width: 140px; /* Match button width */
        }

        .stat-box:hover {
            transform: translateY(-3px);
            box-shadow: 0 6px 15px rgba(0, 0, 0, 0.2);
        }

        .stat-box i {
            font-size: 1.2rem;
        }

        .goals-section {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .section-title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 15px;
            color: var(--primary);
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .section-title i {
            margin-right: 10px;
            color: var(--accent);
        }

        .goal-card {
            background: white;
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 15px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.05);
            border-left: 5px solid var(--primary);
            transition: transform 0.3s, box-shadow 0.3s;
        }

        .goal-card:hover {
            transform: translateX(5px) translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.1);
        }

        .goal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .goal-title {
            font-size: 1.2rem;
            font-weight: 600;
            color: var(--dark);
        }

        .goal-actions {
            display: flex;
            gap: 10px;
        }

        .btn {
            background: var(--primary);
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 5px;
            transition: transform 0.2s, background 0.2s, box-shadow 0.2s;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        .btn:hover {
            background: var(--secondary);
            transform: translateY(-2px);
            box-shadow: 0 6px 10px rgba(0, 0, 0, 0.15);
        }

        .btn-add {
            background: var(--success);
        }

        .btn-add:hover {
            background: #2bb0d8;
        }

        .btn-delete {
            background: var(--danger);
        }

        .btn-delete:hover {
            background: #c1121f;
        }

        .btn-success {
            background: var(--success);
        }

        .btn-success:hover {
            background: #2bb0d8;
        }

        .btn-warning {
            background: var(--warning);
        }

        .btn-warning:hover {
            background: #e29005;
        }

        .subtasks {
            list-style-type: none;
        }

        .subtask-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 12px;
            border-bottom: 1px solid #eee;
            transition: background 0.2s, transform 0.2s;
            border-radius: 6px;
        }

        .subtask-item:hover {
            background: #f8f9fa;
            transform: translateX(3px);
        }

        .subtask-item:last-child {
            border-bottom: none;
        }

        .subtask-checkbox {
            appearance: none;
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            border: 2px solid var(--primary);
            border-radius: 5px;
            cursor: pointer;
            position: relative;
            transition: background 0.2s;
        }

        .subtask-checkbox:checked {
            background: var(--primary);
        }

        .subtask-checkbox:checked::after {
            content: 'âœ“';
            position: absolute;
            color: white;
            font-size: 14px;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        .subtask-checkbox:hover {
            background: rgba(67, 97, 238, 0.1);
        }

        .subtask-content {
            flex: 1;
        }

        .subtask-title {
            font-weight: 500;
        }

        .subtask-time {
            font-size: 0.85rem;
            color: #888;
            margin-top: 5px;
        }

        .subtask-info {
            font-size: 0.85rem;
            margin: 4px 0;
            background-color: rgba(67, 97, 238, 0.05);
            padding: 3px 6px;
            border-radius: 4px;
            border-left: 3px solid var(--primary);
        }

        .dark-mode .subtask-info {
            background-color: rgba(76, 201, 240, 0.1);
            border-left: 3px solid var(--success);
        }

        .subtask-notes {
            font-size: 0.85rem;
            color: #888;
            margin-top: 5px;
        }

        .subtask-actions {
            display: flex;
            gap: 5px;
        }

        .subtask-btn {
            background: none;
            border: none;
            cursor: pointer;
            font-size: 1rem;
            transition: color 0.2s;
        }

        .edit-btn {
            color: var(--primary);
        }

        .edit-btn:hover {
            color: var(--secondary);
        }

        .delete-btn {
            color: var(--danger);
        }

        .delete-btn:hover {
            color: #c1121f;
        }

        /* Difficulty badge styles */
        .difficulty-badge {
            display: inline-block;
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 0.7rem;
            font-weight: 600;
            margin-left: 5px;
            color: white;
        }

        .difficulty-easy {
            background-color: #4cc9f0;
        }

        .difficulty-medium {
            background-color: #fca311;
        }

        .difficulty-hard {
            background-color: #e63946;
        }

        /* Undo button styles */
        .undo-button {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 999;
            background-color: var(--warning);
            color: white;
            border: none;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.5rem;
            cursor: pointer;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease, transform 0.3s ease;
        }
        
        .undo-button.show {
            opacity: 1;
            pointer-events: auto;
            animation: pulse 1.5s infinite;
        }
        
        .undo-button:hover {
            transform: scale(1.1);
            background-color: var(--accent);
        }
        
        @keyframes pulse {
            0% { box-shadow: 0 0 0 0 rgba(252, 163, 17, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(252, 163, 17, 0); }
            100% { box-shadow: 0 0 0 0 rgba(252, 163, 17, 0); }
        }

        .add-subtask-form {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }

        .form-input {
            flex: 3;
            padding: 8px 12px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-size: 0.9rem;
            transition: border 0.2s;
        }

        .form-input:focus {
            border-color: var(--primary);
            outline: none;
        }

        .form-input-time {
            flex: 1;
        }

        .stats-section, .leaderboard-section, .graph-section, .motivation-section {
            margin-bottom: 20px;
        }

        .leaderboard-list {
            list-style-type: none;
            padding: 0;
            margin: 0;
        }

        .leaderboard-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px;
            border-bottom: 1px solid #eee;
            transition: background 0.2s;
        }

        .leaderboard-item:hover {
            background: #f8f9fa;
        }

        .leaderboard-item:last-child {
            border-bottom: none;
        }

        .leaderboard-rank {
            width: 30px;
            height: 30px;
            display: flex;
            justify-content: center;
            align-items: center;
            background: var(--primary);
            color: white;
            border-radius: 50%;
            font-weight: 600;
        }

        .user-entry {
            background: rgba(67, 97, 238, 0.1);
            border-left: 5px solid var(--primary);
        }

        .user-entry .leaderboard-rank {
            background: var(--accent);
        }

        .leaderboard-name {
            flex: 1;
            margin-left: 10px;
            font-weight: 500;
        }

        .leaderboard-score {
            font-weight: 600;
            color: var(--primary);
        }

        .motivation-quote {
            font-style: italic;
            text-align: center;
            padding: 20px;
            border-radius: 10px;
            background: rgba(76, 201, 240, 0.1);
            border-left: 5px solid var(--success);
            margin: 15px 0;
            font-weight: 500;
            font-size: 1.1rem;
            line-height: 1.6;
        }

        .daily-actions {
            display: flex;
            gap: 10px;
            margin-top: 15px;
            margin-bottom: 15px;
        }

        .daily-actions .btn {
            flex: 1;
            padding: 15px;
            font-weight: 600;
            font-size: 1rem;
            box-shadow: var(--card-shadow);
            transition: transform 0.3s, box-shadow 0.3s;
            text-align: center;
            justify-content: center;
            min-width: 0;
        }

        .daily-actions .btn:hover {
            transform: translateY(-5px);
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.2);
        }

        .daily-actions .btn i {
            margin-right: 8px;
        }

        .streak-badge {
            display: inline-flex;
            align-items: center;
            gap: 5px;
            background: linear-gradient(135deg, #fddb27, #fd7f1b);
            color: white;
            padding: 5px 10px;
            border-radius: 20px;
            font-weight: 600;
            box-shadow: 0 4px 8px rgba(253, 127, 27, 0.3);
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }

        .milestone-badge {
            display: inline-flex;
            align-items: center;
            gap: 5px;
            background: linear-gradient(135deg, #4cc9f0, #4361ee);
            color: white;
            padding: 5px 10px;
            border-radius: 20px;
            font-weight: 600;
            margin-left: 10px;
            box-shadow: 0 4px 8px rgba(76, 201, 240, 0.3);
        }

        .badges-container {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 15px;
        }

        /* Confetti animation */
        .confetti-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            pointer-events: none;
            z-index: 9999;
            display: none;
        }

        .confetti {
            position: absolute;
            top: -10px;
            animation: fall linear forwards, sway 3s ease-in-out infinite alternate;
            z-index: 9999;
            transform-origin: center center;
        }

        @keyframes fall {
            0% {
                top: -10%;
                transform: rotate(0deg);
            }
            100% {
                top: 100%;
                transform: rotate(360deg);
            }
        }

        @keyframes sway {
            0% {
                margin-left: 0;
            }
            25% {
                margin-left: 25px;
            }
            50% {
                margin-left: -15px;
            }
            75% {
                margin-left: 10px;
            }
            100% {
                margin-left: -5px;
            }
        }

        /* Add new sparkle animation for confetti */
        @keyframes sparkle {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        /* Add new rotation animation for confetti */
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Add new scale animation for confetti */
        @keyframes scale {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.2); }
        }

        /* Catch-up mode styles */
        .catch-up-mode {
            background: linear-gradient(135deg, #fca311, #e63946);
            color: white;
            padding: 15px;
            border-radius: 10px;
            margin-top: 20px;
            box-shadow: 0 4px 12px rgba(230, 57, 70, 0.3);
            display: none;
        }

        .catch-up-mode h3 {
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .catch-up-task {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 10px;
            margin-top: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .catch-up-task-title {
            font-weight: 500;
        }

        .catch-up-task-points {
            background: white;
            color: var(--danger);
            padding: 3px 8px;
            border-radius: 10px;
            font-weight: 600;
        }
        
        .add-goal-container {
            text-align: center;
            margin: 20px 0;
        }
        
        .goal-input {
            width: 100%;
            padding: 10px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-size: 1rem;
            margin-bottom: 10px;
        }
        
        .goal-input:focus {
            border-color: var(--primary);
            outline: none;
        }
        
        /* Modal styles */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }
        
        .modal-content {
            background: white;
            padding: 30px;
            border-radius: 15px;
            max-width: 500px;
            width: 90%;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
        }
        
        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }
        
        .modal-title {
            font-size: 1.5rem;
            font-weight: 600;
            color: var(--primary);
        }
        
        .close-modal {
            background: none;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            color: #6c757d;
        }
        
        .form-group {
            margin-bottom: 15px;
        }
        
        .form-label {
            display: block;
            margin-bottom: 5px;
            font-weight: 500;
        }
        
        .completed {
            text-decoration: line-through;
            opacity: 0.7;
        }
        
        .empty-state {
            text-align: center;
            padding: 30px;
            color: #6c757d;
            background: rgba(255,255,255,0.05);
            border-radius: 10px;
            margin-top: 20px;
        }
        
        .empty-state i {
            font-size: 3rem;
            margin-bottom: 15px;
            color: var(--primary-light);
        }
        
        .welcome-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 2000;
            justify-content: center;
            align-items: center;
        }
        
        .welcome-content {
            background: var(--card-bg);
            color: inherit;
            padding: 30px;
            border-radius: 15px;
            max-width: 600px;
            width: 90%;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            text-align: center;
        }
        
        .welcome-title {
            font-size: 2rem;
            color: var(--primary);
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .welcome-title i {
            color: var(--accent);
        }

        .dark-mode .welcome-title {
            color: var(--primary-light);
        }

        .welcome-message {
            font-size: 1.1rem;
            line-height: 1.6;
            margin-bottom: 20px;
            color: inherit;
        }
        
        .welcome-steps {
            list-style: none;
            padding: 0;
            margin: 20px 0;
        }
        
        .welcome-steps li {
            padding: 12px;
            margin-bottom: 10px;
            border-radius: 8px;
            border-left: 3px solid var(--primary);
            background: rgba(255, 255, 255, 0.05);
            transition: transform 0.3s, background 0.3s;
            display: flex;
            align-items: center;
        }
        
        .welcome-steps li:hover {
            transform: translateX(5px);
            background: rgba(255, 255, 255, 0.1);
        }
        
        .dark-mode .welcome-steps li {
            background: rgba(0, 0, 0, 0.1);
            border-left-color: var(--primary-light);
        }
        
        .dark-mode .welcome-steps li:hover {
            background: rgba(0, 0, 0, 0.2);
        }
        
        .welcome-steps li i {
            color: var(--success);
            margin-right: 10px;
            font-size: 1.1rem;
        }
        
        .welcome-actions {
            margin-top: 30px;
        }

        .history-section {
            margin-top: 20px;
            border-top: 1px solid rgba(255, 255, 255, 0.3);
            padding-top: 15px;
        }
        
        .history-header {
            cursor: pointer;
            font-weight: 600;
            color: var(--primary);
            padding: 10px;
            transition: color 0.2s;
            display: flex;
            align-items: center;
        }
        
        .history-header:hover {
            color: var(--accent);
        }
        
        .history-header i {
            margin-right: 10px;
            transition: transform 0.3s;
        }
        
        .history-header.expanded i {
            transform: rotate(90deg);
        }
        
        .history-content {
            display: none;
            padding: 15px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            margin-top: 10px;
        }
        
        .history-day {
            margin-bottom: 15px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            padding-bottom: 10px;
        }
        
        .history-day-header {
            font-weight: 600;
            margin-bottom: 10px;
            color: var(--primary-light);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        
        .history-day-content {
            padding-left: 20px;
        }
        
        .history-task {
            padding: 8px 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .history-task.completed {
            color: var(--success);
        }
        
        .history-task.incomplete {
            color: var(--danger);
        }
        
        .history-datepicker {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }
        
        .history-datepicker input {
            padding: 8px;
            border-radius: 5px;
            border: 1px solid var(--primary-light);
        }
        
        .history-datepicker button {
            padding: 8px 15px;
            background: var(--primary);
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }
        
        #resetProgressBtn {
            margin-left: 15px;
            background-color: var(--danger);
        }
        
        #resetProgressBtn:hover {
            background-color: #c1121f;
        }

        /* Timer Modal styles */
        .timer-container {
            text-align: center;
        }

        .timer-display {
            font-size: 2rem;
            font-weight: 700;
            margin-bottom: 20px;
        }

        .timer-task-info {
            margin-bottom: 20px;
        }

        .timer-controls {
            margin-bottom: 20px;
        }

        .pomodoro-settings {
            margin-bottom: 20px;
        }

        .timer-progress {
            margin-bottom: 20px;
        }

        .timer-progress-bar-container {
            width: 100%;
            height: 20px;
            background-color: #eee;
            border-radius: 10px;
            overflow: hidden;
        }

        .timer-progress-bar {
            height: 100%;
            background-color: var(--primary);
            transition: width 0.5s ease;
        }

        .timer-progress-text {
            margin-bottom: 10px;
        }

        .dark-mode {
            --primary: #4cc9f0;
            --primary-light: #4895ef;
            --secondary: #4361ee;
            --accent: #f72585;
            --light: #e0e1dd;
            --dark: #f8f9fa;
            --success: #52b788;
            --warning: #fca311;
            --danger: #e63946;
            --bg-gradient: linear-gradient(135deg, #1b263b, #0d1b2a);
            --card-bg: rgba(34, 40, 49, 0.9);
            --card-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
            color: var(--light);
        }
        
        #darkModeToggle.active {
            background-color: #f8f9fa;
            color: #1b263b;
        }
        
        #darkModeToggle.active i {
            transform: rotate(180deg);
        }

        /* Add quote management to the customization container */
        .card {
            background: var(--card-bg);
            border-radius: 15px;
            box-shadow: var(--card-shadow);
            padding: 20px;
            backdrop-filter: blur(10px);
            transition: transform 0.3s, box-shadow 0.3s;
        }

        /* Update the style for the stats tabs to make them look better */
        .stats-tabs {
            display: flex;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            overflow: hidden;
            margin-bottom: 15px;
        }
        
        .stats-tab {
            flex: 1;
            padding: 10px;
            text-align: center;
            background: none;
            border: none;
            cursor: pointer;
            font-weight: 600;
            color: var(--dark);
            transition: background 0.3s, color 0.3s;
        }
        
        .stats-tab:hover {
            background: rgba(255, 255, 255, 0.2);
        }
        
        .stats-tab.active {
            background: var(--primary);
            color: white;
        }
        
        /* Fix for dark mode compatibility */
        .dark-mode .stats-tab {
            color: var(--light);
        }

        /* Add smooth scrolling */
        html {
            scroll-behavior: smooth;
        }

        /* Improve header appearance */
        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            grid-column: 1 / -1;
            background: var(--card-bg);
            border-radius: 15px;
            padding: 20px;
            box-shadow: var(--card-shadow);
            /* Removed sticky positioning */
            position: relative;
            z-index: 10;
        }

        /* Improved stat boxes */
        .stat-box {
            background: linear-gradient(135deg, var(--primary-light), var(--primary));
            color: white;
            padding: 10px 15px;
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center; /* Center content like buttons */
            gap: 10px;
            font-weight: 600;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            transition: transform 0.2s, box-shadow 0.2s;
            height: 42px; /* Match button height */
            min-width: 140px; /* Match button width */
        }

        .stat-box:hover {
            transform: translateY(-3px);
            box-shadow: 0 6px 15px rgba(0, 0, 0, 0.2);
        }

        /* Improved button styling */
        .btn {
            background: var(--primary);
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 5px;
            transition: transform 0.2s, background 0.2s, box-shadow 0.2s;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        .btn:hover {
            background: var(--secondary);
            transform: translateY(-2px);
            box-shadow: 0 6px 10px rgba(0, 0, 0, 0.15);
        }

        /* Improved goal card styling */
        .goal-card {
            background: white;
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 15px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.05);
            border-left: 5px solid var(--primary);
            transition: transform 0.3s, box-shadow 0.3s;
        }

        .goal-card:hover {
            transform: translateX(5px) translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.1);
        }

        /* Improve subtask styling */
        .subtask-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 12px;
            border-bottom: 1px solid #eee;
            transition: background 0.2s, transform 0.2s;
            border-radius: 6px;
        }

        .subtask-item:hover {
            background: #f8f9fa;
            transform: translateX(3px);
        }

        /* Custom scrollbar for better UX */
        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.05);
            border-radius: 10px;
        }

        ::-webkit-scrollbar-thumb {
            background: rgba(67, 97, 238, 0.3);
            border-radius: 10px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: rgba(67, 97, 238, 0.5);
        }

        /* Improve dark mode compatibility */
        .dark-mode .goal-card {
            background: rgba(30, 35, 45, 0.8);
            border-left-color: var(--primary-light);
        }

        .dark-mode .subtask-item {
            border-bottom-color: rgba(255, 255, 255, 0.1);
        }

        .dark-mode .subtask-item:hover {
            background: rgba(255, 255, 255, 0.05);
        }

        /* Enhanced Leaderboard Styles */
        .leaderboard-container {
            overflow: hidden;
            border-radius: 10px;
            background: rgba(255, 255, 255, 0.05);
            margin-bottom: 15px;
        }

        .leaderboard-header {
            display: flex;
            justify-content: space-between;
            padding: 12px 15px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            background: rgba(0, 0, 0, 0.1);
            font-weight: 600;
            color: #4cc9f0; /* Changed from var(--light) to a bright blue */
        }

        .leaderboard-header-rank {
            width: 40px;
            text-align: center;
        }

        .leaderboard-header-name {
            flex: 1;
            margin-left: 10px;
        }

        .leaderboard-header-score {
            width: 80px;
            text-align: right;
        }

        .leaderboard-list {
            list-style-type: none;
            padding: 0;
            margin: 0;
        }

        .leaderboard-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .leaderboard-item:last-child {
            border-bottom: none;
        }

        .leaderboard-item:hover {
            background: rgba(255, 255, 255, 0.1);
            transform: translateX(5px);
        }

        .leaderboard-rank {
            width: 40px;
            height: 40px;
            display: flex;
            justify-content: center;
            align-items: center;
            color: #fff0d9; /* Changed from default white to a warm cream color */
            border-radius: 50%;
            font-weight: 600;
            font-size: 1.1rem;
            position: relative;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            transition: transform 0.3s, box-shadow 0.3s;
        }

        .leaderboard-rank::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border-radius: 50%;
            background: conic-gradient(transparent 0%, rgba(255, 255, 255, 0.2) 50%, transparent 100%);
            animation: spin 4s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .rank-1 {
            background: linear-gradient(135deg, #FFD700, #FFA500);
            transform: scale(1.1);
        }

        .rank-2 {
            background: linear-gradient(135deg, #C0C0C0, #A9A9A9);
            transform: scale(1.05);
        }

        .rank-3 {
            background: linear-gradient(135deg, #CD7F32, #8B4513);
            transform: scale(1.02);
        }

        .rank-other {
            background: var(--primary);
        }

        .user-entry {
            background: rgba(67, 97, 238, 0.15);
            border-left: 5px solid var(--primary);
            animation: pulse-bg 2s infinite;
        }

        @keyframes pulse-bg {
            0% { background-color: rgba(67, 97, 238, 0.15); }
            50% { background-color: rgba(67, 97, 238, 0.25); }
            100% { background-color: rgba(67, 97, 238, 0.15); }
        }

        .user-entry .leaderboard-rank {
            background: linear-gradient(135deg, var(--accent), var(--primary));
        }

        .leaderboard-name {
            flex: 1;
            margin-left: 15px;
            font-weight: 500;
            font-size: 1rem;
            display: flex;
            align-items: center;
            gap: 8px;
            color: #f8f9fa; /* Changed to a very light gray for better readability */
        }

        .leaderboard-name .user-indicator {
            font-size: 0.7rem;
            background: var(--accent);
            color: #fffdf0; /* Changed to a warm bright color */
            padding: 2px 6px;
            border-radius: 10px;
        }

        .leaderboard-score {
            font-weight: 700;
            color: #4cc9f0; /* Changed from var(--light) to match header */
            font-size: 1.1rem;
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            padding-right: 5px;
        }

        .score-change {
            font-size: 0.7rem;
            margin-top: 3px;
            padding: 2px 5px;
            border-radius: 10px;
            animation: fade-in 0.5s ease-out;
        }

        .score-increase {
            color: #4cc9f0;
        }

        .score-decrease {
            color: #f77474;
        }

        @keyframes fade-in {
            from { opacity: 0; transform: translateY(5px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* Animation for position changes */
        .position-change-up, .position-change-down {
            animation: highlight 2s ease-out;
        }

        .position-change-indicator {
            font-size: 0.8rem;
            padding: 2px 4px;
            border-radius: 3px;
            margin-left: 5px;
        }

        .position-up {
            color: #4cc9f0;
        }

        .position-down {
            color: #f77474;
        }

        @keyframes highlight {
            0% { background-color: rgba(76, 201, 240, 0.3); }
            100% { background-color: transparent; }
        }

        .progress-bar-container {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 3px;
            background: rgba(255, 255, 255, 0.1);
            overflow: hidden;
        }

        .progress-bar {
            height: 100%;
            width: 0%;
            background: linear-gradient(to right, var(--primary), var(--accent));
            transition: width 0.8s ease-in-out;
        }

        .crown-icon {
            color: gold;
            font-size: 1.2rem;
            margin-right: 5px;
            filter: drop-shadow(0 0 2px rgba(255, 215, 0, 0.5));
        }

        .user-entry .leaderboard-name {
            color: #ffd166; /* Give the user's name a gold tint */
            font-weight: 600; /* Make it slightly bolder */
        }

        /* Add different text colors for each rank position */
        .rank-1-name {
            color: #FFD700 !important; /* Gold */
            font-weight: 700;
            text-shadow: 0 0 5px rgba(255, 215, 0, 0.3);
        }

        .rank-2-name {
            color: #C0C0C0 !important; /* Silver */
            font-weight: 600;
        }

        .rank-3-name {
            color: #CD7F32 !important; /* Bronze */
            font-weight: 600;
        }

        .rank-4-name {
            color: #4cc9f0 !important; /* Light blue */
        }

        .rank-5-name {
            color: #06d6a0 !important; /* Mint green */
        }

        .rank-6-name {
            color: #ffd166 !important; /* Light orange */
        }

        .rank-7-name {
            color: #ef476f !important; /* Coral pink */
        }

        .rank-8-name {
            color: #a2d2ff !important; /* Light sky blue */
        }

        .rank-9-name {
            color: #9896f1 !important; /* Lavender */
        }

        .rank-10-name {
            color: #fb5607 !important; /* Orange */
        }

        /* Default color for ranks beyond 10 */
        .rank-other-name {
            color: #f8f9fa !important; /* Light gray */
        }

        /* Override for user's name regardless of position */
        .user-entry .leaderboard-name {
            color: #ffd166 !important; /* Golden yellow */
            font-weight: 600;
            text-shadow: 0 0 5px rgba(255, 209, 102, 0.3);
        }

        /* Analysis Modal Styles */
        .analysis-container {
            display: flex;
            flex-direction: column;
            gap: 20px;
            padding: 10px 0;
        }

        .analysis-tabs {
            display: flex;
            gap: 5px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            padding-bottom: 10px;
            overflow-x: auto;
        }

        .analysis-tab {
            background: rgba(255, 255, 255, 0.1);
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-weight: 600;
            transition: background 0.3s;
            color: var(--light);
            white-space: nowrap;
        }

        .analysis-tab:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .analysis-tab.active {
            background: var(--primary);
            color: white;
        }

        .analysis-tab-content {
            display: none;
            padding: 20px 10px;
        }

        .analysis-tab-content.active {
            display: block;
            animation: fadeIn 0.5s ease-in-out;
        }

        .analysis-charts-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }

        .analysis-chart {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            padding: 15px;
            box-shadow: var(--card-shadow); /* Use theme shadow */
        }

        .dark-mode .analysis-chart {
            background: rgba(0, 0, 0, 0.2); /* Darker background in dark mode */
        }

        .analysis-metrics-container {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }

        .analysis-metric {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            padding: 15px;
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
            box-shadow: var(--card-shadow); /* Use theme shadow */
        }

        .dark-mode .analysis-metric {
            background: rgba(0, 0, 0, 0.2); /* Darker background in dark mode */
        }

        .metric-value {
            font-size: 1.8rem;
            font-weight: 700;
            margin: 10px 0;
            color: var(--primary-light); /* Use theme primary light color */
        }

        .metric-label {
            font-size: 0.9rem;
            color: inherit; /* Inherit text color */
            opacity: 0.8;
        }

        .habit-patterns-list, .insights-container, .recommendations-container {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .pattern-item, .insight-item, .recommendation-item {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            padding: 15px;
            box-shadow: var(--card-shadow); /* Use theme shadow */
            transition: transform 0.3s ease;
        }

        .dark-mode .pattern-item, 
        .dark-mode .insight-item, 
        .dark-mode .recommendation-item {
            background: rgba(0, 0, 0, 0.2); /* Darker background in dark mode */
        }

        .pattern-item:hover, .insight-item:hover, .recommendation-item:hover {
            transform: translateY(-3px);
        }

        .pattern-item h4, .insight-item h4, .recommendation-item h4 {
            margin-top: 0;
            color: var(--primary-light); /* Use theme primary light color */
            display: flex;
            align-items: center;
            gap: 8px;
        }

        /* Ensure consistent modal appearance with theme */
        #analysisModal .modal-content {
            background: var(--card-bg); /* Use theme card background */
            color: inherit; /* Inherit text color */
            box-shadow: var(--card-shadow); /* Use theme shadow */
        }

        #analysisModal .modal-header {
            border-bottom-color: rgba(255, 255, 255, 0.1);
        }

        #analysisModal h3, #analysisModal h4 {
            color: var(--primary); /* Use theme primary color for headings */
        }

        .dark-mode #analysisModal h3, .dark-mode #analysisModal h4 {
            color: var(--primary-light); /* Use theme primary light in dark mode */
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        @media (max-width: 768px) {
            .analysis-charts-container {
                grid-template-columns: 1fr;
            }
        }

        /* Ensure all modals have consistent appearance with theme */
        .modal .modal-content {
            background: var(--card-bg); /* Use theme card background */
            color: inherit; /* Inherit text color */
            box-shadow: var(--card-shadow); /* Use theme shadow */
            border: none;
        }

        .modal .modal-header {
            border-bottom-color: rgba(255, 255, 255, 0.1);
        }

        .modal h2, .modal h3, .modal h4 {
            color: var(--primary); /* Use theme primary color for headings */
        }

        .dark-mode .modal h2, .dark-mode .modal h3, .dark-mode .modal h4 {
            color: var(--primary-light); /* Use theme primary light in dark mode */
        }

        .modal label {
            color: inherit;
        }

        .modal input, .modal select, .modal textarea {
            background-color: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: inherit;
        }

        .dark-mode .modal input, .dark-mode .modal select, .dark-mode .modal textarea {
            background-color: rgba(0, 0, 0, 0.2);
            border-color: rgba(255, 255, 255, 0.1);
        }

        /* Override specific styles for each modal type */
        /* Timer Modal */
        #timerModal .timer-display {
            background: var(--primary-light);
            color: white;
        }

        .dark-mode #timerModal .timer-display {
            background: var(--primary);
        }

        #timerModal .pomodoro-settings {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            padding: 15px;
        }

        /* Competitor Modal */
        #competitorModal .intensity-option {
            background: rgba(255, 255, 255, 0.05);
        }

        .dark-mode #competitorModal .intensity-option {
            background: rgba(0, 0, 0, 0.2);
        }

        #competitorModal .competitor-item {
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        /* Analysis Modal - already styled */

        /* Customization section styles */
        .customization-container {
            margin-top: 30px;
            border-radius: 15px;
            background: var(--card-bg);
            box-shadow: var(--card-shadow);
            overflow: hidden;
        }
        
        .customization-section {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
            gap: 15px;
            padding: 15px;
        }
        
        /* Update collapsible header for customization */
        .collapsible-header {
            padding: 12px 20px;
            background: linear-gradient(90deg, var(--primary-light), var(--primary));
            color: white;
            font-weight: 600;
            cursor: pointer;
            transition: background 0.3s;
        }
        
        .collapsible-header:hover {
            background: linear-gradient(90deg, var(--primary), var(--secondary));
        }
        
        .customization-box {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            padding: 15px;
            border: 1px solid rgba(67, 97, 238, 0.1);
            transition: transform 0.2s, box-shadow 0.2s;
        }
        
        .customization-box:hover {
            transform: translateY(-3px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
        }
        
        .customization-box h4 {
            font-size: 1rem;
            margin-top: 0;
            margin-bottom: 10px;
            color: var(--primary);
            display: flex;
            align-items: center;
        }
        
        .customization-box h4 i {
            margin-right: 8px;
        }
        
        .dark-mode .customization-box {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(76, 201, 240, 0.1);
        }
        
        .dark-mode .customization-box h4 {
            color: var(--success);
        }
    </style>
</head>
<body>
    <!-- Undo Button -->
    <button id="undoButton" class="undo-button" title="Undo last action">
        <i class="fas fa-undo"></i>
    </button>
    
    <div class="confetti-container" id="confetti-container"></div>
    
    <div class="app-container">
        <div class="header full-width-section">
            <h1><i class="fas fa-rocket"></i> Habit Tracker</h1>
            <div class="user-stats">
                <div class="stat-box">
                    <i class="fas fa-star"></i>
                    <span id="total-score">0</span> Points
                </div>
                <div class="stat-box">
                    <i class="fas fa-fire"></i>
                    <span id="streak-count">0</span> Days
                </div>
                <button id="darkModeToggle" class="btn dark-toggle">
                    <i class="fas fa-moon"></i> Dark Mode
                </button>
                <button id="exportDataBtn" class="btn btn-success">
                    <i class="fas fa-file-export"></i> Backup
                </button>
                <button id="importDataBtn" class="btn btn-warning">
                    <i class="fas fa-file-import"></i> Restore
                </button>
                <button id="resetProgressBtn" class="btn btn-danger">
                    <i class="fas fa-undo"></i> Reset Progress
                </button>
            </div>
        </div>
        
        <!-- Daily Goals Section -->
        <div class="goals-section card">
            <div class="section-title">
                <span><i class="fas fa-bullseye"></i> Daily Goals</span>
                <button id="addGoalBtn" class="btn btn-add"><i class="fas fa-plus"></i> Add Goal</button>
            </div>
            
            <div id="goalsContainer">
                <!-- Goals will be added here dynamically -->
                <div class="empty-state" id="emptyGoalsState">
                    <i class="fas fa-check-circle" style="color: var(--success);"></i>
                    <p>You've completed all your goals for today! Great job!</p>
                    <p>Come back tomorrow to set new goals or click "Prepare Tomorrow" to get started early.</p>
                </div>
            </div>
        </div>
        
        <!-- Daily Motivation Section (moved to its own column) -->
        <div class="motivation-section card">
            <div class="section-title">
                <span><i class="fas fa-lightbulb"></i> Daily Motivation</span>
            </div>
            <div class="motivation-quote" id="motivationQuote">
                "The only way to do great work is to love what you do." - Steve Jobs
            </div>
            <div class="quote-controls" style="display: flex; justify-content: space-between; margin-top: 10px;">
                <button id="prevQuoteBtn" class="btn btn-primary" style="flex: 1; margin-right: 5px;">
                    <i class="fas fa-chevron-left"></i> Prev
                </button>
                <button id="nextQuoteBtn" class="btn btn-primary" style="flex: 1; margin-left: 5px;">
                    <i class="fas fa-chevron-right"></i> Next
                </button>
            </div>
            <div class="quote-management" style="margin-top: 10px;">
                <button id="addQuoteModalBtn" class="btn btn-success" style="width: 100%; margin-bottom: 5px;">
                    <i class="fas fa-plus"></i> Add Quote
                </button>
                <button id="manageQuotesBtn" class="btn btn-primary" style="width: 100%; transition: background-color 0.3s;">
                    <i class="fas fa-cog"></i> Manage Quotes
                </button>
            </div>
            <div class="badges-container" id="badgesContainer">
                <!-- Badges will be added here dynamically -->
            </div>
        </div>
        
        <!-- Leaderboard Section -->
        <div class="stats-section card">
            <h2>Real-Time Leaderboard</h2>
            <div class="leaderboard-container">
                <div class="leaderboard-header">
                    <div class="leaderboard-header-rank">#</div>
                    <div class="leaderboard-header-name">Competitor</div>
                    <div class="leaderboard-header-score">Score</div>
                </div>
                <ul class="leaderboard-list" id="leaderboardList">
                    <!-- Leaderboard items will be dynamically added here -->
                </ul>
            </div>
            <button class="btn" id="customizeCompetitors">Customize Competitors</button>
        </div>
        
        <!-- Progress Chart Section -->
        <div class="graph-section card">
            <div class="section-title">
                <span><i class="fas fa-chart-line"></i> Progress</span>
            </div>
            <canvas id="progressChart"></canvas>
            
            <div class="stats-details" style="margin-top: 20px;">
                <div class="stats-tabs">
                    <button class="stats-tab active" data-tab="summary">Summary</button>
                    <button class="stats-tab" data-tab="daily">Daily</button>
                    <button class="stats-tab" data-tab="weekly">Weekly</button>
                    <button class="stats-tab" data-tab="trends">Trends</button>
                </div>
                
                <div class="stats-content" id="stats-summary" style="display: block;">
                    <div class="stats-grid" style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-top: 15px;">
                        <div class="stats-card" style="background: rgba(255,255,255,0.1); padding: 10px; border-radius: 10px;">
                            <h4>Total Points</h4>
                            <p class="stats-value" id="stats-total-points">0</p>
                        </div>
                        <div class="stats-card" style="background: rgba(255,255,255,0.1); padding: 10px; border-radius: 10px;">
                            <h4>Current Streak</h4>
                            <p class="stats-value" id="stats-current-streak">0 days</p>
                        </div>
                        <div class="stats-card" style="background: rgba(255,255,255,0.1); padding: 10px; border-radius: 10px;">
                            <h4>Total Tasks</h4>
                            <p class="stats-value" id="stats-total-tasks">0</p>
                        </div>
                        <div class="stats-card" style="background: rgba(255,255,255,0.1); padding: 10px; border-radius: 10px;">
                            <h4>Completion Rate</h4>
                            <p class="stats-value" id="stats-completion-rate">0%</p>
                        </div>
                    </div>
                </div>
                
                <div class="stats-content" id="stats-daily" style="display: none;">
                    <div style="margin-top: 15px;">
                        <h4>Points Today</h4>
                        <div class="progress-bar" style="height: 20px; background: rgba(255,255,255,0.1); border-radius: 10px; overflow: hidden; margin: 10px 0;">
                            <div id="today-progress" style="height: 100%; background: var(--primary); width: 0%;"></div>
                        </div>
                        <p><span id="today-points">0</span> points out of daily goal of <span id="daily-goal">50</span> points</p>
                        
                        <h4>Tasks Completed Today</h4>
                        <div id="today-tasks-chart">
                            <!-- Will be filled with a chart -->
                            <canvas id="tasksDonutChart" style="max-height: 200px;"></canvas>
                        </div>
                    </div>
                </div>
                
                <div class="stats-content" id="stats-weekly" style="display: none;">
                    <div style="margin-top: 15px;">
                        <h4>Weekly Performance</h4>
                        <canvas id="weeklyChart" style="max-height: 200px;"></canvas>
                        
                        <div style="margin-top: 15px;">
                            <h4>Most Productive Day</h4>
                            <p id="most-productive-day">-</p>
                            
                            <h4>Weekly Average</h4>
                            <p id="weekly-average">0 points/day</p>
                        </div>
                    </div>
                </div>
                
                <div class="stats-content" id="stats-trends" style="display: none;">
                    <div style="margin-top: 15px;">
                        <h4>Point Trends</h4>
                        <canvas id="trendsChart" style="max-height: 200px;"></canvas>
                        
                        <div class="trend-insights" style="margin-top: 15px;">
                            <div class="trend-card" style="background: rgba(255,255,255,0.1); padding: 10px; border-radius: 10px; margin-bottom: 10px;">
                                <h4>Performance Trend</h4>
                                <p id="performance-trend">Stable</p>
                            </div>
                            <div class="trend-card" style="background: rgba(255,255,255,0.1); padding: 10px; border-radius: 10px;">
                                <h4>Consistency Score</h4>
                                <p id="consistency-score">0%</p>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="daily-actions full-width-section">
            <button id="completeDayBtn" class="btn btn-success">
                <i class="fas fa-check-circle"></i> Complete & Reflect
            </button>
            <button id="prepareTomorrowBtn" class="btn btn-warning">
                <i class="fas fa-calendar-plus"></i> Prepare Tomorrow
            </button>
            <button id="analysisBtn" class="btn btn-primary">
                <i class="fas fa-chart-bar"></i> Analysis
            </button>
        </div>
        
        <!-- New Customization Container at the bottom -->
        <div class="customization-container full-width-section">
            <div class="section-title collapsible-header" id="customizationHeader">
                <span><i class="fas fa-sliders-h"></i> Customization Options</span>
                <i class="fas fa-chevron-down" id="customizationChevron"></i>
            </div>
            
            <div class="customization-section" id="customizationContent" style="display: none;">
                <!-- History Section -->
                <div class="customization-box">
                    <h4><i class="fas fa-history"></i> History</h4>
                    <div class="history-section" id="historySection">
                        <div class="history-header" id="historyHeader">
                            <i class="fas fa-history"></i> View History
                        </div>
                        <div class="history-content" id="historyContent">
                            <!-- History content will be added here dynamically -->
                        </div>
                    </div>
                </div>
                
                <!-- Graph Customization -->
                <div class="customization-box">
                    <h4><i class="fas fa-paint-brush"></i> Graph Appearance</h4>
                    <div class="form-group">
                        <label for="userLineColor">Your Line Color:</label>
                        <input type="color" id="userLineColor" class="form-input" value="#f72585">
                    </div>
                    <div class="form-group">
                        <label for="graphBackground">Graph Background:</label>
                        <input type="color" id="graphBackgroundColor" class="form-input" value="#ffffff">
                    </div>
                    <div class="settings-toggle">
                        <span>Show Grid Lines</span>
                        <label class="toggle-switch">
                            <input type="checkbox" id="showGridLines" checked>
                            <span class="toggle-slider"></span>
                        </label>
                    </div>
                    <button id="applyGraphSettings" class="btn btn-primary" style="width: 100%; margin-top: 10px;">
                        <i class="fas fa-check"></i> Apply Changes
                    </button>
                </div>
                
                <!-- Theme Settings -->
                <div class="customization-box">
                    <h4><i class="fas fa-palette"></i> Theme Settings</h4>
                    <div class="theme-selector">
                        <div class="theme-option theme-default active" data-theme="default">Default</div>
                        <div class="theme-option theme-ocean" data-theme="ocean">Ocean</div>
                        <div class="theme-option theme-forest" data-theme="forest">Forest</div>
                        <div class="theme-option theme-sunset" data-theme="sunset">Sunset</div>
                        <div class="theme-option theme-dark" data-theme="dark">Dark</div>
                    </div>
                    <div class="form-group" style="margin-top: 15px;">
                        <label class="form-label" for="fontSelector">Font Style:</label>
                        <div class="font-selector">
                            <div class="font-option font-sans active" data-font="sans">Sans</div>
                            <div class="font-option font-serif" data-font="serif">Serif</div>
                            <div class="font-option font-mono" data-font="mono">Mono</div>
                        </div>
                    </div>
                </div>
                
                <!-- Timer Settings -->
                <div class="customization-box">
                    <h4><i class="fas fa-clock"></i> Timer Settings</h4>
                    <div class="form-group">
                        <label for="defaultWorkTime">Work time (minutes)</label>
                        <input type="number" id="defaultWorkTime" class="form-input" value="25" min="1" max="60">
                    </div>
                    <div class="form-group">
                        <label for="defaultBreakTime">Break time (minutes)</label>
                        <input type="number" id="defaultBreakTime" class="form-input" value="5" min="1" max="30">
                    </div>
                    <div class="settings-toggle">
                        <span>Sound notifications</span>
                        <label class="toggle-switch">
                            <input type="checkbox" id="soundToggle" checked>
                            <span class="toggle-slider"></span>
                        </label>
                    </div>
                    <div class="form-group" style="margin-top: 15px;">
                        <label style="display: block; margin-bottom: 8px;">Quick Timer Controls:</label>
                        <div style="display: flex; gap: 10px;">
                            <button id="quickStartTimerBtn" class="btn btn-success" style="flex: 1; padding: 8px;">
                                <i class="fas fa-play"></i> Start
                            </button>
                            <button id="quickPauseTimerBtn" class="btn btn-warning" style="flex: 1; padding: 8px;">
                                <i class="fas fa-pause"></i> Pause
                            </button>
                            <button id="quickResetTimerBtn" class="btn btn-danger" style="flex: 1; padding: 8px;">
                                <i class="fas fa-undo"></i> Reset
                            </button>
                        </div>
                    </div>
                </div>
                
                <!-- Other Settings -->
                <div class="customization-box">
                    <h4><i class="fas fa-cog"></i> Additional Settings</h4>
                    <div class="settings-toggle">
                        <span>Auto-complete at midnight</span>
                        <label class="toggle-switch">
                            <input type="checkbox" id="autoCompleteToggle" checked>
                            <span class="toggle-slider"></span>
                        </label>
                    </div>
                    <div class="settings-toggle">
                        <span>Confetti effects</span>
                        <label class="toggle-switch">
                            <input type="checkbox" id="confettiToggle" checked>
                            <span class="toggle-slider"></span>
                        </label>
                    </div>
                    <div class="form-group">
                        <label for="dailyPointsGoal">Daily Points Goal:</label>
                        <input type="number" id="dailyPointsGoal" class="form-input" value="50" min="10" max="200">
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Add Goal Modal -->
    <div class="modal" id="addGoalModal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 class="modal-title">Add New Goal</h2>
                <button class="close-modal" id="closeGoalModal">&times;</button>
            </div>
            <div class="form-group">
                <label class="form-label" for="goalTitle">Goal Title:</label>
                <input type="text" id="goalTitle" class="form-input" placeholder="Enter goal title" required>
            </div>
            <button id="saveGoalBtn" class="btn btn-success">
                <i class="fas fa-save"></i> Save Goal
            </button>
        </div>
    </div>
    
    <!-- Add Subtask Modal -->
    <div class="modal" id="addSubtaskModal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 class="modal-title">Add New Subtask</h2>
                <button class="close-modal" id="closeSubtaskModal">&times;</button>
            </div>
            <div class="form-group">
                <label class="form-label" for="subtaskTitle">Subtask Title:</label>
                <input type="text" id="subtaskTitle" class="form-input" placeholder="Enter subtask title" required>
            </div>
            <div class="form-group">
                <label class="form-label" for="subtaskTime">Time Frame (optional):</label>
                <input type="text" id="subtaskTime" class="form-input" placeholder="e.g. 8-9 AM">
            </div>
            <div class="form-group">
                <label class="form-label" for="subtaskDifficulty">Difficulty Level:</label>
                <select id="subtaskDifficulty" class="form-input">
                    <option value="easy" selected>Easy (x1 points)</option>
                    <option value="medium">Medium (x2 points)</option>
                    <option value="hard">Hard (x3 points)</option>
                </select>
            </div>
            <div class="form-group">
                <label class="form-label" for="subtaskSubject">Subject/Topic:</label>
                <input type="text" id="subtaskSubject" class="form-input" placeholder="e.g. Math, Physics, Programming">
            </div>
            <div class="form-group">
                <label class="form-label" for="subtaskLecture">Lecture Number:</label>
                <input type="number" id="subtaskLecture" class="form-input" placeholder="e.g. 5" min="1">
            </div>
            <div class="form-group">
                <label class="form-label" for="subtaskNotes">Notes (optional):</label>
                <textarea id="subtaskNotes" class="form-input" placeholder="Add notes or details about this subtask" rows="3"></textarea>
            </div>
            <input type="hidden" id="currentGoalId">
            <button id="saveSubtaskBtn" class="btn btn-success">
                <i class="fas fa-save"></i> Save Subtask
            </button>
        </div>
    </div>
    
    <!-- Welcome Modal -->
    <div class="welcome-modal" id="welcomeModal">
        <div class="welcome-content">
            <h2 class="welcome-title"><i class="fas fa-rocket"></i> Welcome to Habit Tracker!</h2>
            <p class="welcome-message">
                This app will help you build great habits with a fun, competitive approach.
                Here's how it works:
            </p>
            <ul class="welcome-steps">
                <li><i class="fas fa-check-circle"></i> Set up to 3 daily goals with subtasks</li>
                <li><i class="fas fa-check-circle"></i> Each subtask you complete earns 5 points</li>
                <li><i class="fas fa-check-circle"></i> Complete at least one subtask in each goal to earn a 10-point bonus!</li>
                <li><i class="fas fa-check-circle"></i> Compete with virtual opponents on the leaderboard</li>
                <li><i class="fas fa-check-circle"></i> Track your progress with graphs and earn streak badges</li>
                <li><i class="fas fa-check-circle"></i> Set tomorrow's goals each night to stay consistent</li>
            </ul>
            <div class="welcome-actions">
                <button id="startHabitTracker" class="btn btn-success">
                    <i class="fas fa-play"></i> Let's Get Started!
                </button>
            </div>
        </div>
    </div>

    <!-- Reset Confirmation Modal -->
    <div class="modal" id="resetConfirmationModal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 class="modal-title">Reset Progress Confirmation</h2>
                <button class="close-modal" id="closeResetModal">&times;</button>
            </div>
            <p>Are you sure you want to reset all your progress? This cannot be undone!</p>
            <p>Type "CONFIRM" below to proceed:</p>
            <div class="form-group">
                <input type="text" id="resetConfirmInput" class="form-input" placeholder="Type CONFIRM here">
            </div>
            <button id="confirmResetBtn" class="btn btn-danger">
                <i class="fas fa-exclamation-triangle"></i> Reset All Progress
            </button>
        </div>
    </div>

    <!-- Competitor Customization Modal -->
    <div class="modal" id="competitorModal">
        <div class="modal-content" style="max-width: 600px; width: 90%;">
            <div class="modal-header">
                <h2 class="modal-title">Customize Competitors</h2>
                <button class="close-modal" id="closeCompetitorModal">&times;</button>
            </div>
            <div id="competitorsList" style="max-height: 250px; overflow-y: auto; margin-bottom: 20px; border: 1px solid #eee; border-radius: 8px; padding: 10px;">
                <!-- Competitors will be listed here dynamically -->
            </div>
            <div style="background: rgba(67, 97, 238, 0.1); border-radius: 8px; padding: 15px; margin-bottom: 15px;">
                <h3 style="margin-bottom: 15px; font-size: 1.2rem;">Add New Competitor</h3>
                <div class="form-group">
                    <label class="form-label" for="newCompetitorName">Competitor Name:</label>
                    <input type="text" id="newCompetitorName" class="form-input" placeholder="Enter competitor name">
                </div>
                <div class="form-group">
                    <label class="form-label" for="newCompetitorIntensity">Intensity Level:</label>
                    <select id="newCompetitorIntensity" class="form-input">
                        <option value="easy">Easy (Stays behind you)</option>
                        <option value="medium" selected>Medium (Competitive)</option>
                        <option value="hard">Hard (Always ahead)</option>
                    </select>
                </div>
                <button id="addCompetitorBtn" class="btn btn-success" style="width: 100%;">
                    <i class="fas fa-plus"></i> Add Competitor
                </button>
            </div>
        </div>
    </div>

    <!-- Timer Modal -->
    <div class="modal" id="timerModal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 class="modal-title">Task Timer</h2>
                <button class="close-modal" id="closeTimerModal">&times;</button>
            </div>
            <div class="timer-container">
                <div class="timer-display" style="font-size: 3rem; font-weight: 700; margin-bottom: 20px; text-align: center; padding: 15px; background: rgba(67, 97, 238, 0.1); border-radius: 10px;">
                    <span id="timerMinutes">25</span>:<span id="timerSeconds">00</span>
                </div>
                <div class="timer-task-info" style="text-align: center; margin-bottom: 20px; font-size: 1.2rem;">
                    <p>Working on: <strong id="timerTaskName">Task Name</strong></p>
                </div>
                <div class="timer-controls" style="display: flex; justify-content: space-around; gap: 10px; margin-bottom: 25px;">
                    <button id="startTimerBtn" class="btn btn-success" style="flex: 1; padding: 12px; font-size: 1.1rem;">
                        <i class="fas fa-play"></i> Start
                    </button>
                    <button id="pauseTimerBtn" class="btn btn-warning" disabled style="flex: 1; padding: 12px; font-size: 1.1rem;">
                        <i class="fas fa-pause"></i> Pause
                    </button>
                    <button id="resetTimerBtn" class="btn btn-danger" style="flex: 1; padding: 12px; font-size: 1.1rem;">
                        <i class="fas fa-undo"></i> Reset
                    </button>
                </div>
                <div class="timer-controls" style="display: flex; justify-content: space-around; gap: 10px; margin-bottom: 25px;">
                    <button id="skipWorkBtn" class="btn" style="flex: 1; padding: 8px; background-color: #6c757d; color: white;">
                        <i class="fas fa-forward"></i> Skip to Break
                    </button>
                    <button id="skipBreakBtn" class="btn" style="flex: 1; padding: 8px; background-color: #6c757d; color: white;">
                        <i class="fas fa-forward"></i> Skip to Work
                    </button>
                </div>
                <div class="pomodoro-settings">
                    <h3>Pomodoro Settings</h3>
                    <div class="form-group">
                        <label for="pomodoroWork">Work Time (minutes):</label>
                        <input type="number" id="pomodoroWork" class="form-input" value="25" min="1" max="60">
                    </div>
                    <div class="form-group">
                        <label for="pomodoroBreak">Break Time (minutes):</label>
                        <input type="number" id="pomodoroBreak" class="form-input" value="5" min="1" max="30">
                    </div>
                    <div class="form-group">
                        <label for="pomodoroCycles">Cycles until long break:</label>
                        <input type="number" id="pomodoroCycles" class="form-input" value="4" min="1" max="10">
                    </div>
                    <div class="form-group">
                        <label for="pomodoroLongBreak">Long Break (minutes):</label>
                        <input type="number" id="pomodoroLongBreak" class="form-input" value="15" min="5" max="60">
                    </div>
                </div>
                <div class="timer-progress">
                    <div class="timer-progress-text">Completed: <span id="pomodoroProgress">0/4</span> cycles</div>
                    <div class="timer-progress-bar-container">
                        <div class="timer-progress-bar" id="pomodoroProgressBar"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Import Data Modal -->
    <div class="modal" id="importDataModal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 class="modal-title">Import Data</h2>
                <button class="close-modal" id="closeImportModal">&times;</button>
            </div>
            <p>Paste your exported JSON data below:</p>
            <div class="form-group">
                <textarea id="importDataText" class="form-input" style="height: 200px; font-family: monospace;" placeholder="Paste JSON data here"></textarea>
            </div>
            <div class="modal-footer">
                <button id="confirmImportBtn" class="btn btn-success">
                    <i class="fas fa-file-import"></i> Import Data
                </button>
            </div>
        </div>
    </div>

    <!-- Daily Reflection Modal -->
    <div class="modal" id="reflectionModal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 class="modal-title">Daily Reflection</h2>
                <button class="close-modal" id="closeReflectionModal">&times;</button>
            </div>
            <p>Take a moment to reflect on your day. What went well? What could be improved?</p>
            <div class="form-group">
                <label for="reflectionDate">Date:</label>
                <input type="date" id="reflectionDate" class="form-input" disabled>
            </div>
            <div class="form-group">
                <label for="reflectionMood">Overall Mood:</label>
                <select id="reflectionMood" class="form-input">
                    <option value="great">Great ðŸ˜„</option>
                    <option value="good" selected>Good ðŸ™‚</option>
                    <option value="okay">Okay ðŸ˜</option>
                    <option value="bad">Not Great ðŸ˜•</option>
                    <option value="terrible">Terrible ðŸ˜ž</option>
                </select>
            </div>
            <div class="form-group">
                <label for="reflectionText">Reflection:</label>
                <textarea id="reflectionText" class="form-input" rows="5" placeholder="What did you learn today? What are you proud of? What could you have done better?"></textarea>
            </div>
            <div class="form-group">
                <label for="tomorrowFocus">Focus for Tomorrow:</label>
                <input type="text" id="tomorrowFocus" class="form-input" placeholder="What will you focus on tomorrow?">
            </div>
            <button id="saveReflectionBtn" class="btn btn-success">
                <i class="fas fa-save"></i> Save Reflection
            </button>
        </div>
    </div>

    <!-- Settings Button -->
    <button class="settings-btn" id="settingsBtn">
        <i class="fas fa-cog"></i>
    </button>
    
    <!-- Settings Panel -->
    <div class="settings-panel" id="settingsPanel">
        <div class="settings-header">
            <h2 class="settings-title">Settings</h2>
            <button class="close-settings" id="closeSettings">&times;</button>
        </div>
        
        <div class="settings-section">
            <h3 class="settings-section-title">Theme</h3>
            <div class="theme-selector">
                <div class="theme-option theme-default active" data-theme="default">Default</div>
                <div class="theme-option theme-ocean" data-theme="ocean">Ocean</div>
                <div class="theme-option theme-forest" data-theme="forest">Forest</div>
                <div class="theme-option theme-sunset" data-theme="sunset">Sunset</div>
                <div class="theme-option theme-dark" data-theme="dark">Dark</div>
            </div>
        </div>
        
        <div class="settings-section">
            <h3 class="settings-section-title">Font</h3>
            <div class="font-selector">
                <div class="font-option font-sans active" data-font="sans">Sans</div>
                <div class="font-option font-serif" data-font="serif">Serif</div>
                <div class="font-option font-mono" data-font="mono">Mono</div>
            </div>
        </div>
        
        <div class="settings-section">
            <h3 class="settings-section-title">Preferences</h3>
            
            <div class="settings-toggle">
                <span>Auto-complete at midnight</span>
                <label class="toggle-switch">
                    <input type="checkbox" id="autoCompleteToggle" checked>
                    <span class="toggle-slider"></span>
                </label>
            </div>
            
            <div class="settings-toggle">
                <span>Sound notifications</span>
                <label class="toggle-switch">
                    <input type="checkbox" id="soundToggle" checked>
                    <span class="toggle-slider"></span>
                </label>
            </div>
            
            <div class="settings-toggle">
                <span>Confetti effects</span>
                <label class="toggle-switch">
                    <input type="checkbox" id="confettiToggle" checked>
                    <span class="toggle-slider"></span>
                </label>
            </div>
        </div>
        
        <div class="settings-section">
            <h3 class="settings-section-title">Timer Settings</h3>
            <div class="form-group">
                <label for="defaultWorkTime">Default work time (minutes)</label>
                <input type="number" id="defaultWorkTime" class="form-input" value="25" min="1" max="60">
            </div>
            <div class="form-group">
                <label for="defaultBreakTime">Default break time (minutes)</label>
                <input type="number" id="defaultBreakTime" class="form-input" value="5" min="1" max="30">
            </div>
        </div>
    </div>

    <!-- Add quote management to the customization container -->
    <div class="card">
        <div class="section-title">
            <span><i class="fas fa-quote-left"></i> Manage Quotes</span>
        </div>
        <div class="quotes-manager">
            <div class="form-group">
                <label for="newQuote">Add New Quote:</label>
                <textarea id="newQuote" class="form-input" rows="3" placeholder="Enter a motivational quote"></textarea>
            </div>
            <div class="form-group">
                <label for="quoteAuthor">Author (optional):</label>
                <input type="text" id="quoteAuthor" class="form-input" placeholder="Quote author">
            </div>
            <button id="addQuoteBtn" class="btn btn-success" style="width: 100%;">
                <i class="fas fa-plus"></i> Add Quote
            </button>
            
            <div class="quotes-list-container" style="margin-top: 15px; max-height: 200px; overflow-y: auto;">
                <h4>Your Custom Quotes:</h4>
                <ul id="quotesList" class="quotes-list" style="list-style: none; padding: 0;">
                    <!-- Quotes will be listed here -->
                </ul>
            </div>
        </div>
    </div>

    <!-- Add Quote Modal -->
    <div class="modal" id="addQuoteModal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 class="modal-title">Add New Quote</h2>
                <button class="close-modal" id="closeAddQuoteModal">&times;</button>
            </div>
            <div class="form-group">
                <label for="newQuoteText">Quote:</label>
                <textarea id="newQuoteText" class="form-input" rows="3" placeholder="Enter a motivational quote"></textarea>
            </div>
            <div class="form-group">
                <label for="newQuoteAuthor">Author (optional):</label>
                <input type="text" id="newQuoteAuthor" class="form-input" placeholder="Quote author">
            </div>
            <button id="saveQuoteBtn" class="btn btn-success" style="width: 100%;">
                <i class="fas fa-save"></i> Save Quote
            </button>
        </div>
    </div>

    <!-- Manage Quotes Modal -->
    <div class="modal" id="manageQuotesModal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 class="modal-title">Manage Quotes</h2>
                <button class="close-modal" id="closeManageQuotesModal">&times;</button>
            </div>
            <div class="quotes-list-container" style="max-height: 300px; overflow-y: auto; margin-bottom: 15px;">
                <ul id="manageQuotesList" class="quotes-list" style="list-style: none; padding: 0;">
                    <!-- Quotes will be listed here -->
                </ul>
            </div>
        </div>
    </div>

    <!-- Analysis Modal -->
    <div class="modal" id="analysisModal">
        <div class="modal-content" style="max-width: 90%; width: 900px; max-height: 85vh; overflow-y: auto;">
            <div class="modal-header">
                <h2 class="modal-title">Detailed Analysis</h2>
                <button class="close-modal" id="closeAnalysisModal">&times;</button>
            </div>
            <div class="analysis-container">
                <div class="analysis-tabs">
                    <button class="analysis-tab active" data-tab="performance">Performance</button>
                    <button class="analysis-tab" data-tab="habits">Habit Patterns</button>
                    <button class="analysis-tab" data-tab="insights">Insights</button>
                    <button class="analysis-tab" data-tab="recommendations">Recommendations</button>
                </div>
                <div class="analysis-content">
                    <div id="performance-tab" class="analysis-tab-content active">
                        <h3>Performance Analysis</h3>
                        <div class="analysis-charts-container">
                            <div class="analysis-chart">
                                <h4>Task Completion Rate</h4>
                                <canvas id="taskCompletionChart" height="300"></canvas>
                            </div>
                            <div class="analysis-chart">
                                <h4>Score Progression</h4>
                                <canvas id="scoreProgressionChart" height="300"></canvas>
                            </div>
                            <div class="analysis-chart">
                                <h4>Task Distribution</h4>
                                <canvas id="taskDistributionChart" height="300"></canvas>
                            </div>
                        </div>
                        <div class="analysis-metrics-container">
                            <!-- Performance metrics will be added here -->
                        </div>
                    </div>
                    <div id="habits-tab" class="analysis-tab-content">
                        <h3>Habit Patterns</h3>
                        <div class="analysis-charts-container">
                            <div class="analysis-chart">
                                <h4>Daily Activity Heatmap</h4>
                                <div id="heatmapContainer"></div>
                            </div>
                            <div class="analysis-chart">
                                <h4>Task Type Distribution</h4>
                                <canvas id="taskDistributionChart" height="250"></canvas>
                            </div>
                        </div>
                        <div class="habit-patterns-list">
                            <!-- Habit patterns will be added here -->
                        </div>
                    </div>
                    <div id="insights-tab" class="analysis-tab-content">
                        <h3>Key Insights</h3>
                        <div class="insights-container">
                            <!-- Insights will be added here -->
                        </div>
                    </div>
                    <div id="recommendations-tab" class="analysis-tab-content">
                        <h3>Personalized Recommendations</h3>
                        <div class="recommendations-container">
                            <!-- Recommendations will be added here -->
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Data structure
        let habitData = {
            user: {
                name: "You",
                score: 0,
                streak: 0,
                lastActive: null,
                history: [],
                milestones: [],
                dailyHistory: {}, // This will store the daily tasks history
                reflections: {}
            },
            goals: [],
            competitors: [
                { name: "Alex", score: 50, history: [], intensity: "medium" },
                { name: "Jamie", score: 35, history: [], intensity: "medium" },
                { name: "Taylor", score: 30, history: [], intensity: "medium" },
                { name: "Morgan", score: 25, history: [], intensity: "medium" },
                { name: "Casey", score: 100, history: [], intensity: "hard" }
            ],
            settings: {
                theme: 'default',
                font: 'sans',
                autoComplete: true,
                soundNotifications: true,
                confettiEffects: true,
                defaultWorkTime: 25,
                defaultBreakTime: 5,
                dailyPointsGoal: 50
            },
            customQuotes: [],
            lastReset: null
        };
        
        // Motivational quotes
        const motivationalQuotes = [
            "The secret of getting ahead is getting started. - Mark Twain",
            "It's not about being the best. It's about being better than you were yesterday.",
            "Don't watch the clock; do what it does. Keep going. - Sam Levenson",
            "Success is not final, failure is not fatal: It is the courage to continue that counts. - Winston Churchill",
            "The only way to do great work is to love what you do. - Steve Jobs",
            "The harder you work for something, the greater you'll feel when you achieve it.",
            "Dream it. Wish it. Do it.",
            "Your only limit is you.",
            "Discipline is choosing between what you want now and what you want most.",
            "Small daily improvements are the key to staggering long-term results.",
            "The difference between try and triumph is a little umph.",
            "Don't stop when you're tired. Stop when you're done.",
            "Wake up with determination. Go to bed with satisfaction.",
            "It always seems impossible until it's done. - Nelson Mandela",
            "Fall seven times, stand up eight. - Japanese Proverb"
        ];
        
        // DOM Elements
        const goalsContainer = document.getElementById('goalsContainer');
        const emptyGoalsState = document.getElementById('emptyGoalsState');
        const leaderboardList = document.getElementById('leaderboardList');
        const totalScoreElement = document.getElementById('total-score');
        const streakCountElement = document.getElementById('streak-count');
        const motivationQuoteElement = document.getElementById('motivationQuote');
        const badgesContainer = document.getElementById('badgesContainer');
        const progressChart = document.getElementById('progressChart');
        const confettiContainer = document.getElementById('confetti-container');
        
        // Modal Elements
        const addGoalModal = document.getElementById('addGoalModal');
        const closeGoalModal = document.getElementById('closeGoalModal');
        const addGoalBtn = document.getElementById('addGoalBtn');
        const saveGoalBtn = document.getElementById('saveGoalBtn');
        const goalTitleInput = document.getElementById('goalTitle');
        
        const addSubtaskModal = document.getElementById('addSubtaskModal');
        const closeSubtaskModal = document.getElementById('closeSubtaskModal');
        const saveSubtaskBtn = document.getElementById('saveSubtaskBtn');
        const subtaskTitleInput = document.getElementById('subtaskTitle');
        const subtaskTimeInput = document.getElementById('subtaskTime');
        const subtaskDifficultyInput = document.getElementById('subtaskDifficulty');
        const subtaskSubjectInput = document.getElementById('subtaskSubject');
        const subtaskLectureInput = document.getElementById('subtaskLecture');
        const subtaskNotesInput = document.getElementById('subtaskNotes');
        const currentGoalIdInput = document.getElementById('currentGoalId');
        
        const completeDayBtn = document.getElementById('completeDayBtn');
        const prepareTomorrowBtn = document.getElementById('prepareTomorrowBtn');
        
        const welcomeModal = document.getElementById('welcomeModal');
        const startHabitTrackerBtn = document.getElementById('startHabitTracker');
        
        let chart; // Global chart reference
        
        // DOM Elements for new features
        const historyHeader = document.getElementById('historyHeader');
        const historyContent = document.getElementById('historyContent');
        const resetProgressBtn = document.getElementById('resetProgressBtn');
        const resetConfirmationModal = document.getElementById('resetConfirmationModal');
        const closeResetModal = document.getElementById('closeResetModal');
        const resetConfirmInput = document.getElementById('resetConfirmInput');
        const confirmResetBtn = document.getElementById('confirmResetBtn');
        
        // Initialize the app
        function initApp() {
            loadData();
            renderGoals();
            updateLeaderboard();
            displayRandomQuote();
            checkStreak();
            renderBadges();
            initChart();
            setupAutoComplete();
            initializeHistory();
            setupGraphCustomization();
            setupRealTimeUpdates();
            setupQuoteManagement();
            setupQuoteNavigation();
            setupCollapsibleSections();
            setupDataOptions();
            
            if (!habitData.user.lastActive) {
                showWelcomeModal();
            }
        }
        
        // Show welcome modal
        function showWelcomeModal() {
            welcomeModal.style.display = 'flex';
        }
        
        // Initialize chart
        function initChart() {
            const ctx = progressChart.getContext('2d');
            
            // Generate some sample data if history is empty
            if (habitData.user.history.length === 0) {
                generateSampleHistory();
            }
            
            // Prepare data for the chart
            const labels = habitData.user.history.map((_, index) => `Day ${index + 1}`);
            const userData = habitData.user.history;
            
            const competitorsData = habitData.competitors.map((competitor, index) => {
                // Generate a different color for each competitor
                const hue = (index * 40) % 360; // Spread colors evenly around the color wheel
                const color = `hsl(${hue}, 70%, 60%)`;
                
                return {
                    label: competitor.name,
                    data: competitor.history,
                    borderColor: color,
                    backgroundColor: 'rgba(0, 0, 0, 0)',
                    borderWidth: 2,
                    tension: 0.3
                };
            });
            
            // Create the chart
            chart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [
                        {
                            label: 'You',
                            data: userData,
                            borderColor: chartColors.userLine,
                            backgroundColor: 'rgba(0, 0, 0, 0)',
                            borderWidth: 3,
                            tension: 0.3
                        },
                        ...competitorsData
                    ]
                },
                options: {
                    responsive: true,
                    scales: {
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: 'Points'
                            },
                            grid: {
                                display: chartColors.showGridLines
                            }
                        },
                        x: {
                            title: {
                                display: true,
                                text: 'Days'
                            },
                            grid: {
                                display: chartColors.showGridLines
                            }
                        }
                    },
                    plugins: {
                        legend: {
                            position: 'bottom'
                        }
                    }
                }
            });
        }

        // Generate sample history data
        function generateSampleHistory() {
            // Generate 7 days of sample data for the user
            habitData.user.history = Array(7).fill(0).map(() => Math.floor(Math.random() * 50));
            
            // Generate data for competitors
            habitData.competitors.forEach(competitor => {
                let competitorHistory = [];
                
                // Generate data based on competitor intensity
                for (let i = 0; i < 7; i++) {
                    let baseScore = habitData.user.history[i];
                    let score;
                    
                    if (competitor.intensity === 'easy') {
                        // Easy competitor stays behind
                        score = Math.max(0, baseScore - 10 - Math.floor(Math.random() * 10));
                    } else if (competitor.intensity === 'medium') {
                        // Medium competitor stays competitive
                        score = baseScore + Math.floor(Math.random() * 20) - 10;
                    } else if (competitor.intensity === 'hard') {
                        // Hard competitor stays ahead
                        score = baseScore + 10 + Math.floor(Math.random() * 20);
                    } else {
                        // Default behavior
                        score = Math.floor(Math.random() * 50);
                    }
                    
                    competitorHistory.push(Math.max(0, score));
                }
                
                competitor.history = competitorHistory;
            });
            
            // Save the updated data
            saveData();
        }

        // Get random color for chart
        function getRandomColor() {
            const colors = [
                '#4361ee', '#4cc9f0', '#4895ef', '#3f37c9', '#3a0ca3', 
                '#480ca8', '#560bad', '#7209b7', '#b5179e', '#f72585'
            ];
            return colors[Math.floor(Math.random() * colors.length)];
        }

        // Load data from localStorage
        function loadData() {
            try {
                const savedData = localStorage.getItem('habitTrackerData');
                if (savedData) {
                    habitData = JSON.parse(savedData);
                    console.log("Data loaded successfully from localStorage");
                } else {
                    console.log("No saved data found in localStorage, using default data");
                }
                
                // Initialize if properties don't exist
                if (!habitData.user) {
                    habitData.user = {
                        name: "You",
                        score: 0,
                        streak: 0,
                        lastActive: null,
                        history: [],
                        milestones: [],
                        dailyHistory: {},
                        reflections: {}
                    };
                }
                
                if (!habitData.goals) {
                    habitData.goals = [];
                }
                
                if (!habitData.competitors) {
                    habitData.competitors = [
                        { name: "Alex", score: 50, history: [], intensity: "medium" },
                        { name: "Jamie", score: 35, history: [], intensity: "medium" },
                        { name: "Taylor", score: 30, history: [], intensity: "medium" },
                        { name: "Morgan", score: 25, history: [], intensity: "medium" },
                        { name: "Casey", score: 100, history: [], intensity: "hard" }
                    ];
                }
                
                if (!habitData.settings) {
                    habitData.settings = {
                        theme: 'default',
                        font: 'sans',
                        autoComplete: true,
                        soundNotifications: true,
                        confettiEffects: true,
                        defaultWorkTime: 25,
                        defaultBreakTime: 5,
                        dailyPointsGoal: 50
                    };
                }
                
                if (!habitData.customQuotes) {
                    habitData.customQuotes = [];
                }
                
                // Check if we need to reset for a new day
                const today = new Date().toLocaleDateString();
                if (habitData.lastReset !== today) {
                    // Update streak based on last active date
                    if (habitData.user.lastActive) {
                        const lastActive = new Date(habitData.user.lastActive);
                        const yesterday = new Date();
                        yesterday.setDate(yesterday.getDate() - 1);
                        
                        if (lastActive.toLocaleDateString() === yesterday.toLocaleDateString()) {
                            // User was active yesterday, increase streak
                            habitData.user.streak++;
                        } else if (lastActive.toLocaleDateString() !== today) {
                            // User missed a day, reset streak
                            habitData.user.streak = 0;
                        }
                    }
                    
                    habitData.lastReset = today;
                    saveData();
                }
            } catch (error) {
                console.error("Error loading data from localStorage:", error);
                
                // If there's an error, initialize with default data
                habitData = {
                    user: {
                        name: "You",
                        score: 0,
                        streak: 0,
                        lastActive: null,
                        history: [],
                        milestones: [],
                        dailyHistory: {},
                        reflections: {}
                    },
                    goals: [],
                    competitors: [
                        { name: "Alex", score: 50, history: [], intensity: "medium" },
                        { name: "Jamie", score: 35, history: [], intensity: "medium" },
                        { name: "Taylor", score: 30, history: [], intensity: "medium" },
                        { name: "Morgan", score: 25, history: [], intensity: "medium" },
                        { name: "Casey", score: 100, history: [], intensity: "hard" }
                    ],
                    settings: {
                        theme: 'default',
                        font: 'sans',
                        autoComplete: true,
                        soundNotifications: true,
                        confettiEffects: true,
                        defaultWorkTime: 25,
                        defaultBreakTime: 5,
                        dailyPointsGoal: 50
                    },
                    customQuotes: [],
                    lastReset: new Date().toLocaleDateString()
                };
                
                saveData();
            }
        }

        // Save data to localStorage
        function saveData() {
            try {
                localStorage.setItem('habitTrackerData', JSON.stringify(habitData));
                console.log("Data saved successfully to localStorage");
            } catch (error) {
                console.error("Error saving data to localStorage:", error);
                alert("There was an error saving your data. Please make sure your browser supports localStorage and you have enough storage space.");
            }
            // Update analysis data when data is saved to ensure it's always in sync
            if (document.getElementById('analysisModal').style.display === 'flex') {
                console.log('Updating analysis data after data change');
                loadAnalysisData();
            }
        }

        // Render goals and subtasks
        function renderGoals() {
            // Filter out completed goals
            const activeGoals = habitData.goals.filter(goal => !goal.completed);
            
            if (activeGoals.length === 0) {
                emptyGoalsState.style.display = 'block';
                emptyGoalsState.innerHTML = `
                    <i class="fas fa-check-circle" style="color: var(--success);"></i>
                    <p>You've completed all your goals for today! Great job!</p>
                    <p>Come back tomorrow to set new goals or click "Prepare Tomorrow" to get started early.</p>
                `;
            } else {
                emptyGoalsState.style.display = 'none';
                
                goalsContainer.innerHTML = '';
                activeGoals.forEach((goal, index) => {
                    const goalId = goal.id;
                    const goalCard = document.createElement('div');
                    goalCard.className = 'goal-card';
                    goalCard.id = `goal-${goalId}`;
                    
                    const goalHeader = document.createElement('div');
                    goalHeader.className = 'goal-header';
                    
                    const goalTitle = document.createElement('h3');
                    goalTitle.className = 'goal-title';
                    goalTitle.textContent = `Goal ${index + 1}: ${goal.title}`;
                    
                    const goalActions = document.createElement('div');
                    goalActions.className = 'goal-actions';
                    
                    const addSubtaskButton = document.createElement('button');
                    addSubtaskButton.className = 'btn btn-add';
                    addSubtaskButton.innerHTML = '<i class="fas fa-tasks"></i> Add Subtask';
                    addSubtaskButton.addEventListener('click', () => openAddSubtaskModal(goalId));
                    
                    const addBonusButton = document.createElement('button');
                    addBonusButton.className = 'btn btn-primary';
                    addBonusButton.style.marginRight = '10px';
                    addBonusButton.innerHTML = '<i class="fas fa-plus-circle"></i> Add Bonus';
                    addBonusButton.addEventListener('click', (e) => {
                        // Create and show dropdown
                        const bonusDropdown = document.createElement('div');
                        bonusDropdown.className = 'bonus-dropdown';
                        bonusDropdown.style.position = 'absolute';
                        
                        // Use theme variables for dropdown styling
                        const isDarkMode = document.body.classList.contains('dark-mode');
                        bonusDropdown.style.backgroundColor = isDarkMode ? 'rgba(20, 25, 35, 0.95)' : 'white';
                        bonusDropdown.style.color = isDarkMode ? '#f8f9fa' : '#212529';
                        bonusDropdown.style.boxShadow = isDarkMode ? 
                            '0 4px 15px rgba(0,0,0,0.3)' : 
                            '0 4px 8px rgba(0,0,0,0.1)';
                        bonusDropdown.style.borderRadius = '8px';
                        bonusDropdown.style.padding = '10px';
                        bonusDropdown.style.zIndex = '100';
                        bonusDropdown.style.minWidth = '200px';
                        bonusDropdown.style.border = isDarkMode ? 
                            '1px solid rgba(255,255,255,0.1)' : 
                            'none';
                        
                        // Position dropdown
                        const rect = e.target.getBoundingClientRect();
                        bonusDropdown.style.top = (rect.bottom + window.scrollY) + 'px';
                        bonusDropdown.style.left = (rect.left + window.scrollX - 150) + 'px';
                        
                        // Check which bonus tasks already exist
                        const hasReading = goal.subtasks.some(task => task.bonusType === 'reading');
                        const hasRevising = goal.subtasks.some(task => task.bonusType === 'revising');
                        const hasPracticing = goal.subtasks.some(task => task.bonusType === 'practicing');
                        
                        // Create items
                        if (!hasReading) {
                            const readingItem = createBonusDropdownItem(goalId, 'Reading', '(8 bonus pts, -2 penalty)', addReadingSubtask);
                            bonusDropdown.appendChild(readingItem);
                        }
                        
                        if (!hasRevising) {
                            const revisingItem = createBonusDropdownItem(goalId, 'Revising', '(10 bonus pts, -2 penalty)', addRevisingSubtask);
                            bonusDropdown.appendChild(revisingItem);
                        }
                        
                        if (!hasPracticing) {
                            const practicingItem = createBonusDropdownItem(goalId, 'Practicing', '(12 bonus pts, -2 penalty)', addPracticingSubtask);
                            bonusDropdown.appendChild(practicingItem);
                        }
                        
                        // If all bonus tasks are already added
                        if (hasReading && hasRevising && hasPracticing) {
                            const noTasksItem = document.createElement('div');
                            noTasksItem.className = 'bonus-item';
                            noTasksItem.style.padding = '8px 12px';
                            noTasksItem.style.cursor = 'default';
                            noTasksItem.style.color = '#6c757d';
                            noTasksItem.textContent = 'All bonus tasks already added';
                            bonusDropdown.appendChild(noTasksItem);
                        }
                        
                        // Add to document and handle clicks
                        document.body.appendChild(bonusDropdown);
                        
                        // Close dropdown when clicking outside
                        const closeDropdown = (event) => {
                            if (!bonusDropdown.contains(event.target) && !addBonusButton.contains(event.target)) {
                                document.body.removeChild(bonusDropdown);
                                document.removeEventListener('click', closeDropdown);
                            }
                        };
                        
                        // Use setTimeout to avoid immediate closure
                        setTimeout(() => {
                            document.addEventListener('click', closeDropdown);
                        }, 0);
                        
                        // Prevent the initial click from closing the dropdown
                        e.stopPropagation();
                    });
                    
                    const deleteGoalButton = document.createElement('button');
                    deleteGoalButton.className = 'btn btn-delete';
                    deleteGoalButton.innerHTML = '<i class="fas fa-trash"></i>';
                    deleteGoalButton.addEventListener('click', () => deleteGoal(goalId));
                    
                    goalActions.appendChild(addBonusButton);
                    goalActions.appendChild(addSubtaskButton);
                    goalActions.appendChild(deleteGoalButton);
                    
                    goalHeader.appendChild(goalTitle);
                    goalHeader.appendChild(goalActions);
                    
                    const subtasksList = document.createElement('ul');
                    subtasksList.className = 'subtasks';
                    
                    if (goal.subtasks.length === 0) {
                        const emptyMessage = document.createElement('li');
                        emptyMessage.className = 'subtask-item';
                        emptyMessage.innerHTML = '<i>No subtasks yet. Add a subtask to get started!</i>';
                        subtasksList.appendChild(emptyMessage);
                    } else {
                        goal.subtasks.forEach(subtask => {
                            const subtaskItem = document.createElement('li');
                            subtaskItem.className = 'subtask-item';
                            if (subtask.completed) {
                                subtaskItem.classList.add('completed');
                            }
                            
                            const checkbox = document.createElement('input');
                            checkbox.type = 'checkbox';
                            checkbox.className = 'subtask-checkbox';
                            checkbox.checked = subtask.completed;
                            checkbox.addEventListener('change', () => toggleSubtask(goalId, subtask.id));
                            
                            const subtaskContent = document.createElement('div');
                            subtaskContent.className = 'subtask-content';
                            
                            const subtaskTitle = document.createElement('div');
                            subtaskTitle.className = 'subtask-title';
                            
                            // Calculate base points based on difficulty
                            let basePoints = 5;
                            if (subtask.difficulty === 'medium') basePoints = 10;
                            else if (subtask.difficulty === 'hard') basePoints = 15;
                            
                            // Calculate bonus points and penalties
                            let bonusPoints = 0;
                            let penaltyPoints = 2; // Default penalty
                            if (subtask.isBonus) {
                                switch (subtask.bonusType) {
                                    case "exercise": 
                                        bonusPoints = 5; 
                                        penaltyPoints = 10; // Exercise has 10-point penalty
                                        break;
                                    case "reading": 
                                        bonusPoints = 8; 
                                        break;
                                    case "revising": 
                                        bonusPoints = 10; 
                                        break;
                                    case "practicing": 
                                        bonusPoints = 12; 
                                        break;
                                }
                            }
                            
                            // Create title with points
                            subtaskTitle.innerHTML = `${subtask.title} 
                                <span style="font-size: 0.8rem; color: var(--success);">
                                    (${basePoints} pts
                                    ${bonusPoints > 0 ? ` + ${bonusPoints} bonus` : ''}
                                    | -${penaltyPoints} penalty)
                                </span>`;
                            
                            // Add difficulty badge
                            if (subtask.difficulty) {
                                const difficultyBadge = document.createElement('span');
                                difficultyBadge.className = `difficulty-badge difficulty-${subtask.difficulty}`;
                                difficultyBadge.textContent = subtask.difficulty.charAt(0).toUpperCase() + subtask.difficulty.slice(1);
                                subtaskTitle.appendChild(difficultyBadge);
                            }
                            
                            subtaskContent.appendChild(subtaskTitle);
                            
                            // Add subject and lecture info if available
                            if (subtask.subject || subtask.lecture) {
                                const subtaskInfo = document.createElement('div');
                                subtaskInfo.className = 'subtask-info';
                                let infoText = '';
                                
                                if (subtask.subject) {
                                    infoText += `<span style="color: var(--primary);">Topic: ${subtask.subject}</span>`;
                                }
                                
                                if (subtask.lecture) {
                                    infoText += infoText ? ' | ' : '';
                                    infoText += `<span style="color: var(--secondary);">Lecture: ${subtask.lecture}</span>`;
                                }
                                
                                subtaskInfo.innerHTML = infoText;
                                subtaskContent.appendChild(subtaskInfo);
                            }
                            
                            if (subtask.time) {
                                const subtaskTime = document.createElement('div');
                                subtaskTime.className = 'subtask-time';
                                subtaskTime.textContent = subtask.time;
                                subtaskContent.appendChild(subtaskTime);
                            }
                            
                            // Show notes on click if they exist
                            if (subtask.notes) {
                                subtaskContent.style.cursor = 'pointer';
                                subtaskContent.addEventListener('click', () => {
                                    alert(`Notes for "${subtask.title}":\n\n${subtask.notes}`);
                                });
                            }
                            
                            const subtaskActions = document.createElement('div');
                            subtaskActions.className = 'subtask-actions';
                            
                            // Add timer button
                            const timerButton = document.createElement('button');
                            timerButton.className = 'subtask-btn';
                            timerButton.innerHTML = '<i class="fas fa-clock"></i>';
                            timerButton.title = 'Start Timer';
                            timerButton.addEventListener('click', () => openTimer(goalId, subtask.id));
                            
                            const deleteSubtaskButton = document.createElement('button');
                            deleteSubtaskButton.className = 'subtask-btn delete-btn';
                            deleteSubtaskButton.innerHTML = '<i class="fas fa-times"></i>';
                            deleteSubtaskButton.addEventListener('click', (e) => {
                                e.stopPropagation();
                                deleteSubtask(goalId, subtask.id);
                            });
                            
                            subtaskActions.appendChild(timerButton);
                            
                            // Always show delete button for all tasks (including bonus tasks)
                            subtaskActions.appendChild(deleteSubtaskButton);
                            
                            subtaskItem.appendChild(checkbox);
                            subtaskItem.appendChild(subtaskContent);
                            subtaskItem.appendChild(subtaskActions);
                            
                            subtasksList.appendChild(subtaskItem);
                        });
                    }
                    
                    goalCard.appendChild(goalHeader);
                    goalCard.appendChild(subtasksList);
                    
                    goalsContainer.appendChild(goalCard);
                });
            }
            
            updateStats();
            
            // After rendering goals, update the analysis data if the modal is open
            const analysisModal = document.getElementById('analysisModal');
            if (analysisModal && analysisModal.style.display === 'flex') {
                console.log('Updating analysis data after rendering goals');
                loadAnalysisData();
            }
        }

        // Function to create bonus dropdown items
        function createBonusDropdownItem(goalId, title, pointsText, addFunction) {
            const item = document.createElement('div');
            item.className = 'bonus-item';
            item.style.padding = '8px 12px';
            item.style.cursor = 'pointer';
            
            // Use theme variables for styling
            const isDarkMode = document.body.classList.contains('dark-mode');
            item.style.borderBottom = isDarkMode ? 
                '1px solid rgba(255,255,255,0.1)' : 
                '1px solid #eee';
            item.style.transition = 'background-color 0.2s, transform 0.2s';
            
            item.innerHTML = `
                <strong>${title}</strong> 
                <span style="font-size: 0.8rem; color: var(--success);">${pointsText}</span>
            `;
            
            item.addEventListener('mouseenter', () => {
                item.style.backgroundColor = isDarkMode ? 
                    'rgba(67, 97, 238, 0.2)' : 
                    'rgba(67, 97, 238, 0.1)';
                item.style.transform = 'translateX(3px)';
            });
            
            item.addEventListener('mouseleave', () => {
                item.style.backgroundColor = 'transparent';
                item.style.transform = 'translateX(0)';
            });
            
            item.addEventListener('click', () => {
                // Add the bonus task
                addFunction(goalId);
                
                // Remove dropdown immediately
                const bonusDropdown = item.parentElement;
                if (bonusDropdown) {
                    document.body.removeChild(bonusDropdown);
                }
                
                // Render goals to update UI
                renderGoals();
                
                // Show confirmation toast
                showToast(`Added ${title} bonus task!`);
            });
            
            return item;
        }

        // Toast notification function
        function showToast(message) {
            // Create toast element
            const toast = document.createElement('div');
            toast.className = 'toast-notification';
            toast.innerHTML = message;
            toast.style.position = 'fixed';
            toast.style.bottom = '20px';
            toast.style.right = '20px';
            toast.style.backgroundColor = 'var(--primary)';
            toast.style.color = 'white';
            toast.style.padding = '12px 20px';
            toast.style.borderRadius = '8px';
            toast.style.boxShadow = '0 4px 12px rgba(0,0,0,0.15)';
            toast.style.zIndex = '9999';
            toast.style.transition = 'opacity 0.3s, transform 0.3s';
            toast.style.opacity = '0';
            toast.style.transform = 'translateY(20px)';
            
            // Add to document
            document.body.appendChild(toast);
            
            // Trigger animation
            setTimeout(() => {
                toast.style.opacity = '1';
                toast.style.transform = 'translateY(0)';
            }, 10);
            
            // Auto-remove after delay
            setTimeout(() => {
                toast.style.opacity = '0';
                toast.style.transform = 'translateY(20px)';
                setTimeout(() => {
                    if (document.body.contains(toast)) {
                        document.body.removeChild(toast);
                    }
                }, 300);
            }, 3000);
        }

        // Toggle subtask completion
        function toggleSubtask(goalId, subtaskId) {
            const goalIndex = habitData.goals.findIndex(goal => goal.id === goalId);
            
            if (goalIndex === -1) {
                console.error('Goal not found:', goalId);
                return;
            }
            
            const subtaskIndex = habitData.goals[goalIndex].subtasks.findIndex(subtask => subtask.id === subtaskId);
            
            if (subtaskIndex === -1) {
                console.error('Subtask not found:', subtaskId);
                return;
            }
            
            const subtask = habitData.goals[goalIndex].subtasks[subtaskIndex];
            const previousState = subtask.completed;
            subtask.completed = !previousState;
            
            let points = 0;
            
            // Calculate points based on difficulty
            switch (subtask.difficulty) {
                case 'easy': points = 5; break;
                case 'medium': points = 10; break;
                case 'hard': points = 15; break;
                default: points = 5;
            }
            
            // Add bonus for subject-specific tasks
            if (subtask.subject) {
                points += 3;
            }
            
            // Add bonus points for bonus tasks
            if (subtask.isBonus && !subtask.isExerciseRequired) {
                // Add bonus points based on bonus type
                let bonusPoints = 0;
                switch (subtask.bonusType) {
                    case "exercise": bonusPoints = 15; break;
                    case "reading": bonusPoints = 8; break;
                    case "revising": bonusPoints = 10; break;
                    case "practicing": bonusPoints = 12; break;
                }
                
                points += bonusPoints;
                
                // Show bonus alert
                if (subtask.completed) {
                    alert(`Great job! You earned ${points} points for completing the ${subtask.title} bonus task! (Includes ${bonusPoints} bonus points)`);
                }
            }
            
            // Update daily history for task completions
            const today = new Date().toLocaleDateString();
            if (!habitData.user.dailyHistory) {
                habitData.user.dailyHistory = {};
            }
            
            if (!habitData.user.dailyHistory[today]) {
                habitData.user.dailyHistory[today] = {
                    pointsEarned: 0,
                    tasksCompleted: 0
                };
            }
            
            // Special handling for the mandatory Exercise subtask
            if (subtask.isExerciseRequired) {
                if (previousState && !subtask.completed) {
                    // If the Exercise subtask is being uncompleted, apply a 10-point penalty
                    habitData.user.score -= 10;
                    showToast('Exercise task undone: -10 points penalty applied!', 'warning');
                    
                    // Decrease the daily task completion count
                    habitData.user.dailyHistory[today].tasksCompleted = Math.max(0, habitData.user.dailyHistory[today].tasksCompleted - 1);
                    habitData.user.dailyHistory[today].pointsEarned = Math.max(0, habitData.user.dailyHistory[today].pointsEarned - points);
                } else if (!previousState && subtask.completed) {
                    // Normal points for completing
                    habitData.user.score += points;
                    showToast(`Exercise task completed: +${points} points!`, 'success');
                    
                    // Increase the daily task completion count
                    habitData.user.dailyHistory[today].tasksCompleted++;
                    habitData.user.dailyHistory[today].pointsEarned += points;
                    
                    // Show confetti for completed tasks
                    if (habitData.settings.confettiEffect !== false) {
                        showConfetti(1);
                    }
                }
            } else {
                // Normal point handling for other tasks
                if (previousState && !subtask.completed) {
                    habitData.user.score -= points;
                    showToast(`Task undone: -${points} points`, 'warning');
                    
                    // Decrease the daily task completion count
                    habitData.user.dailyHistory[today].tasksCompleted = Math.max(0, habitData.user.dailyHistory[today].tasksCompleted - 1);
                    habitData.user.dailyHistory[today].pointsEarned = Math.max(0, habitData.user.dailyHistory[today].pointsEarned - points);
                } else if (!previousState && subtask.completed) {
                habitData.user.score += points;
                    habitData.user.points += points; // Update the points property too
                    showToast(`Task completed: +${points} points!`, 'success');
                    
                    // Increase the daily task completion count
                    habitData.user.dailyHistory[today].tasksCompleted++;
                    habitData.user.dailyHistory[today].pointsEarned += points;
                
                // Show confetti for completed tasks
                if (habitData.settings.confettiEffect !== false) {
                    showConfetti(1);
                    }
                }
            }
            
            // Track this action for undo
            trackAction('toggleSubtask', {
                goalId: goalId,
                subtaskId: subtaskId,
                points: points
            });
            
            saveData();
            renderGoals();
            updateLeaderboard();
            
            // Update analysis data if analysis modal is open
            if (document.getElementById('analysisModal').style.display === 'flex') {
                console.log('Updating analysis data after task completion');
                loadAnalysisData();
            }
        }

        // Check for bonus points
        function checkForBonus() {
            // Check if each goal has at least one completed subtask
            const goalWithCompletedSubtask = habitData.goals.filter(goal => {
                return goal.subtasks.some(subtask => subtask.completed);
            });
            
            // If all goals have a completed subtask and we haven't already awarded the bonus
            if (goalWithCompletedSubtask.length === habitData.goals.length && 
                habitData.goals.length >= 3 && 
                !habitData.goals.bonusAwarded) {
                
                habitData.user.score += 10;
                habitData.goals.bonusAwarded = true;
                showConfetti(30); // Increased from 10 to 30 for a more impressive celebration
                
                // Show a message about the bonus
                alert('Bonus achieved! +10 points for completing subtasks in all goals!');
                
                saveData();
                updateStats();
                updateLeaderboard();
            }
        }

        // Show confetti animation
        function showConfetti(count) {
            confettiContainer.style.display = 'block';
            
            // Increase the number of confetti particles by using a higher multiplier
            for (let i = 0; i < count * 25; i++) {
                const confetti = document.createElement('div');
                confetti.className = 'confetti';
                
                // Random color with more vibrant options
                const colors = ['#f72585', '#4361ee', '#4cc9f0', '#7209b7', '#560bad', '#fca311', '#ff0054', '#ff5400', '#00b4d8', '#7400b8', '#80ffdb'];
                confetti.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
                
                // Random position with better distribution across the screen
                confetti.style.left = Math.random() * 100 + 'vw';
                
                // More varied sizes - from smaller to larger
                const size = (Math.random() * 12) + 5;
                
                // Create different shapes randomly
                const shapes = ['circle', 'square', 'triangle', 'rectangle', 'star'];
                const shape = shapes[Math.floor(Math.random() * shapes.length)];
                
                if (shape === 'circle') {
                    confetti.style.borderRadius = '50%';
                confetti.style.width = size + 'px';
                confetti.style.height = size + 'px';
                } else if (shape === 'triangle') {
                    confetti.style.width = '0';
                    confetti.style.height = '0';
                    confetti.style.backgroundColor = 'transparent';
                    confetti.style.borderLeft = `${size/2}px solid transparent`;
                    confetti.style.borderRight = `${size/2}px solid transparent`;
                    confetti.style.borderBottom = `${size}px solid ${colors[Math.floor(Math.random() * colors.length)]}`;
                } else if (shape === 'rectangle') {
                    confetti.style.width = size * 1.5 + 'px';
                    confetti.style.height = size * 0.5 + 'px';
                } else if (shape === 'star') {
                    // Create a simple star shape using box-shadow
                    confetti.style.width = size/5 + 'px';
                    confetti.style.height = size/5 + 'px';
                    confetti.style.backgroundColor = 'transparent';
                    confetti.style.boxShadow = `0 0 0 ${size/4}px ${colors[Math.floor(Math.random() * colors.length)]}`;
                    confetti.style.transform = 'rotate(45deg)';
                } else {
                    // Square - default
                    confetti.style.width = size + 'px';
                    confetti.style.height = size + 'px';
                }
                
                // Variable animation duration for more natural effect
                const fallDuration = (Math.random() * 3) + 2;
                confetti.style.animationDuration = `${fallDuration}s, ${fallDuration * 0.8}s`;
                
                // Add random additional animations
                const extraAnimations = ['sparkle', 'spin', 'scale'];
                const randomAnim = extraAnimations[Math.floor(Math.random() * extraAnimations.length)];
                const animDuration = (Math.random() * 1) + 0.5;
                
                // Apply the additional animation with the existing ones
                confetti.style.animation += `, ${randomAnim} ${animDuration}s ease-in-out infinite`;
                
                // Random starting delays to make it more natural
                confetti.style.animationDelay = `${Math.random() * 2}s`;
                
                confettiContainer.appendChild(confetti);
                
                // Remove after animation completes
                setTimeout(() => {
                    if (confetti.parentNode === confettiContainer) {
                    confetti.remove();
                    }
                }, fallDuration * 1000 + 2000); // Ensure enough time for the animation to complete
            }
            
            // Extend the display time for the container
            setTimeout(() => {
                confettiContainer.style.display = 'none';
            }, 7000); // Longer display time
        }

        // Add a new goal
        function addGoal(title) {
            // Check if we already created a goal today
            const today = new Date().toLocaleDateString();
            
            if (habitData.goalsCreatedToday === today && habitData.goals.length >= 1) {
                alert('You can only create 1 goal per day. Try adding subtasks to your existing goals instead.');
                return;
            }
            
            const newGoal = {
                id: Date.now(),
                title: title,
                completed: false,
                subtasks: []
            };
            
            habitData.goals.push(newGoal);
            habitData.goalsCreatedToday = today;
            
            // Track this action for undo
            trackAction('addGoal', {
                goalId: newGoal.id
            });
            
            // Automatically add an Exercise subtask that cannot be deleted
            const exerciseSubtask = {
                id: Date.now() + 100, // Ensure unique ID
                title: "Exercise",
                time: "30 mins",
                completed: false,
                isExerciseRequired: true, // Special flag for the mandatory exercise subtask
                isBonus: true, // Flag to prevent normal deletion
                bonusType: "exercise",
                difficulty: "medium"
            };
            
            habitData.goals[habitData.goals.length - 1].subtasks.push(exerciseSubtask);
            
            saveData();
            renderGoals();
            
            // Hide the empty state
            if (emptyGoalsState) {
                emptyGoalsState.style.display = 'none';
            }
        }

        // Delete a goal
        function deleteGoal(goalId) {
            if (confirm('Are you sure you want to delete this goal?')) {
                const goalIndex = habitData.goals.findIndex(goal => goal.id === goalId);
                if (goalIndex === -1) return;
                
                const goal = habitData.goals[goalIndex];
                
                // Track this action for undo
                trackAction('deleteGoal', {
                    goal: goal
                });
                
                habitData.goals.splice(goalIndex, 1);
                saveData();
                renderGoals();
            }
        }

        // Add a subtask
        function addSubtask(goalId, title, time, difficulty, subject, lecture, notes) {
            const goalIndex = habitData.goals.findIndex(goal => goal.id === goalId);
            
            if (goalIndex === -1) {
                console.error('Goal not found:', goalId);
                return;
            }
            
            const newSubtask = {
                id: Date.now(),
                title: title,
                time: time || '',
                completed: false,
                difficulty: difficulty || 'easy',
                subject: subject || '',
                lecture: lecture || '',
                notes: notes || ''
            };
            
            habitData.goals[goalIndex].subtasks.push(newSubtask);
            
            // Track this action for undo
            trackAction('addSubtask', {
                goalId: goalId,
                subtaskId: newSubtask.id
            });
            
            saveData();
            renderGoals();
        }

        // Delete a subtask
        function deleteSubtask(goalId, subtaskId) {
            const goalIndex = habitData.goals.findIndex(goal => goal.id === goalId);
            
            if (goalIndex === -1) {
                console.error('Goal not found:', goalId);
                return;
            }
            
            const subtaskIndex = habitData.goals[goalIndex].subtasks.findIndex(subtask => subtask.id === subtaskId);
            if (subtaskIndex === -1) {
                console.error('Subtask not found:', subtaskId);
                return;
            }
            
            const subtask = habitData.goals[goalIndex].subtasks[subtaskIndex];
            
            // Prevent deletion of the mandatory Exercise subtask
            if (subtask.isExerciseRequired) {
                alert('The Exercise subtask cannot be deleted as it is a mandatory task.');
                return;
            }
            
            // For bonus tasks, confirm deletion with the user
            if (subtask.isBonus) {
                const confirmDelete = confirm(`Are you sure you want to delete the bonus task "${subtask.title}"? You can add it again later from the bonus task menu.`);
                if (!confirmDelete) {
                    return;
                }
            }
            
            // If the subtask was completed, remove points
            if (subtask.completed) {
                // Calculate points based on difficulty
                let points = 5; // Base points
                
                // Multiply based on difficulty
                if (subtask.difficulty === 'easy') {
                    points = 5;
                } else if (subtask.difficulty === 'medium') {
                    points = 10;
                } else if (subtask.difficulty === 'hard') {
                    points = 15;
                }
                
                habitData.user.score -= points;
                if (habitData.user.score < 0) habitData.user.score = 0;
            }
            
            // Track this action for undo
            trackAction('deleteSubtask', {
                goalId: goalId,
                subtask: subtask
            });
            
            habitData.goals[goalIndex].subtasks = habitData.goals[goalIndex].subtasks.filter(subtask => subtask.id !== subtaskId);
            saveData();
            renderGoals();
            updateLeaderboard();
        }

        // Update statistics
        function updateStats() {
            totalScoreElement.textContent = habitData.user.score;
            streakCountElement.textContent = habitData.user.streak;
        }

        // Update leaderboard
        function updateLeaderboard() {
            const leaderboardList = document.getElementById('leaderboardList');

            // Keep track of previous positions for animation effects
            const previousPositions = {};
            const previousScores = {};
            
            // Store previous positions and scores before updating
            Array.from(leaderboardList.children).forEach(item => {
                const name = item.querySelector('.leaderboard-name').textContent.trim().replace(' (You)', '');
                const rankElement = item.querySelector('.leaderboard-rank');
                const scoreElement = item.querySelector('.leaderboard-score');
                
                previousPositions[name] = parseInt(rankElement.textContent);
                previousScores[name] = parseInt(scoreElement.textContent);
            });
            
            // Clear the leaderboard
            leaderboardList.innerHTML = '';
            
            // Create a combined array of competitors and the user
            const allCompetitors = [...habitData.competitors];
            allCompetitors.push({
                name: "You",
                score: habitData.user.score,
                isUser: true
            });
            
            // Sort by score
            allCompetitors.sort((a, b) => b.score - a.score);
            
            // Handle competitor intensity
            for (let i = 0; i < allCompetitors.length; i++) {
                const competitor = allCompetitors[i];
                if (!competitor.isUser && competitor.intensity) {
                    if (competitor.intensity === 'hard') {
                        // Hard competitors always stay ahead of you, but not by too much
                        if (competitor.score <= habitData.user.score) {
                            competitor.score = Math.max(30, habitData.user.score + Math.ceil(Math.random() * 3) + 2);
                        } else if (competitor.score > habitData.user.score + 25) {
                            // Cap the maximum lead to keep it achievable
                            competitor.score = habitData.user.score + 15 + Math.floor(Math.random() * 10);
                        }
                    } else if (competitor.intensity === 'medium') {
                        // Medium competitors stay competitive but beatable
                        if (competitor.score > habitData.user.score + 7) {
                            competitor.score = habitData.user.score + Math.floor(Math.random() * 5) + 2;
                        } else if (competitor.score < habitData.user.score - 7) {
                            competitor.score = Math.max(15, habitData.user.score - Math.floor(Math.random() * 5) - 2);
                        }
                    } else if (competitor.intensity === 'easy') {
                        // Easy competitors always stay behind but not by too much
                        if (competitor.score >= habitData.user.score) {
                            competitor.score = Math.max(10, habitData.user.score - Math.ceil(Math.random() * 3) - 2);
                        } else if (competitor.score < habitData.user.score - 20) {
                            // Don't let them fall too far behind
                            competitor.score = habitData.user.score - 10 - Math.floor(Math.random() * 5);
                        }
                    }
                    
                    // Ensure no negative scores
                    competitor.score = Math.max(1, competitor.score);
                }
            }
            
            // Re-sort after adjusting scores
            allCompetitors.sort((a, b) => b.score - a.score);
            
            // Add items to the leaderboard
            allCompetitors.forEach((competitor, index) => {
                const rank = index + 1;
                const listItem = document.createElement('li');
                listItem.className = 'leaderboard-item';
                
                if (competitor.isUser) {
                    listItem.classList.add('user-entry');
                }
                
                // Position change detection
                const previousPosition = previousPositions[competitor.isUser ? 'You' : competitor.name] || null;
                const previousScore = previousScores[competitor.isUser ? 'You' : competitor.name] || competitor.score;
                
                if (previousPosition && previousPosition !== rank) {
                    if (previousPosition > rank) {
                        listItem.classList.add('position-change-up');
                    } else {
                        listItem.classList.add('position-change-down');
                    }
                }
                
                // Create rank element with appropriate styling
                const rankElement = document.createElement('div');
                rankElement.className = 'leaderboard-rank';
                
                if (rank === 1) {
                    rankElement.classList.add('rank-1');
                } else if (rank === 2) {
                    rankElement.classList.add('rank-2');
                } else if (rank === 3) {
                    rankElement.classList.add('rank-3');
                } else {
                    rankElement.classList.add('rank-other');
                }
                
                rankElement.textContent = rank;
                
                // Create name element
                const nameElement = document.createElement('div');
                nameElement.className = 'leaderboard-name';
                
                // Add appropriate rank-based color class to the name
                if (rank === 1) {
                    nameElement.classList.add('rank-1-name');
                } else if (rank === 2) {
                    nameElement.classList.add('rank-2-name');
                } else if (rank === 3) {
                    nameElement.classList.add('rank-3-name');
                } else if (rank <= 10) {
                    nameElement.classList.add(`rank-${rank}-name`);
                } else {
                    nameElement.classList.add('rank-other-name');
                }
                
                // Add crown icon for first place
                if (rank === 1) {
                    const crownIcon = document.createElement('span');
                    crownIcon.className = 'crown-icon';
                    crownIcon.innerHTML = '<i class="fas fa-crown"></i>';
                    nameElement.appendChild(crownIcon);
                }
                
                // Add name text
                const nameText = document.createTextNode(competitor.isUser ? 'You' : competitor.name);
                nameElement.appendChild(nameText);
                
                // Add 'You' indicator for user
                if (competitor.isUser) {
                    const userIndicator = document.createElement('span');
                    userIndicator.className = 'user-indicator';
                    userIndicator.textContent = 'YOU';
                    nameElement.appendChild(userIndicator);
                }
                
                // Add position change indicator if applicable
                if (previousPosition && previousPosition !== rank) {
                    const changeIndicator = document.createElement('span');
                    changeIndicator.className = 'position-change-indicator';
                    
                    if (previousPosition > rank) {
                        changeIndicator.classList.add('position-up');
                        changeIndicator.innerHTML = `<i class="fas fa-arrow-up"></i> ${previousPosition - rank}`;
                    } else {
                        changeIndicator.classList.add('position-down');
                        changeIndicator.innerHTML = `<i class="fas fa-arrow-down"></i> ${rank - previousPosition}`;
                    }
                    
                    nameElement.appendChild(changeIndicator);
                }
                
                // Create score element
                const scoreElement = document.createElement('div');
                scoreElement.className = 'leaderboard-score';
                scoreElement.textContent = competitor.score;
                
                // Add score change indicator if applicable
                if (previousScore !== competitor.score) {
                    const scoreChange = document.createElement('div');
                    scoreChange.className = 'score-change';
                    
                    if (previousScore < competitor.score) {
                        scoreChange.classList.add('score-increase');
                        scoreChange.innerHTML = `<i class="fas fa-plus"></i>${competitor.score - previousScore}`;
                    } else if (previousScore > competitor.score) {
                        scoreChange.classList.add('score-decrease');
                        scoreChange.innerHTML = `<i class="fas fa-minus"></i>${previousScore - competitor.score}`;
                    }
                    
                    scoreElement.appendChild(scoreChange);
                }
                
                // Add progress bar
                const progressContainer = document.createElement('div');
                progressContainer.className = 'progress-bar-container';
                
                const progressBar = document.createElement('div');
                progressBar.className = 'progress-bar';
                
                progressContainer.appendChild(progressBar);
                
                // Append all elements to the list item
                listItem.appendChild(rankElement);
                listItem.appendChild(nameElement);
                listItem.appendChild(scoreElement);
                listItem.appendChild(progressContainer);
                
                // Add to leaderboard
                leaderboardList.appendChild(listItem);
                
                // Animate the progress bar based on relative score
                setTimeout(() => {
                    const maxScore = allCompetitors[0].score;
                    const percentage = (competitor.score / maxScore) * 100;
                    progressBar.style.width = `${percentage}%`;
                }, 100);
            });
            
            // Add fancy entrance animations
            Array.from(leaderboardList.children).forEach((item, index) => {
                item.style.opacity = '0';
                item.style.transform = 'translateY(20px)';
                setTimeout(() => {
                    item.style.transition = 'opacity 0.5s ease, transform 0.5s ease';
                    item.style.opacity = '1';
                    item.style.transform = 'translateY(0)';
                }, 50 * index);
            });
            
            // Update user history for the chart
            if (habitData.user.history.length > 29) {
                habitData.user.history.shift();
            }
            habitData.user.history.push(habitData.user.score);
            
            // Update competitors' history
            habitData.competitors.forEach(competitor => {
                if (competitor.history.length > 29) {
                    competitor.history.shift();
                }
                competitor.history.push(competitor.score);
            });
            
            saveData();
            updateChart();
            updateAnalytics();
        }

        // Update chart data
        function updateChart() {
            if (chart) {
                chart.data.datasets[0].data = habitData.user.history;
                
                habitData.competitors.forEach((competitor, index) => {
                    chart.data.datasets[index + 1].data = competitor.history;
                });
                
                chart.update();
            }
        }

        // Check streak and add milestones if needed
        function checkStreak() {
            const streakMilestones = [3, 7, 14, 21, 30, 60, 90, 180, 365];
            
            streakMilestones.forEach(milestone => {
                if (habitData.user.streak >= milestone && !habitData.user.milestones.includes(milestone)) {
                    habitData.user.milestones.push(milestone);
                    
                    // Celebrate the milestone
                    showConfetti(50); // Increased from 20 to 50 for a major celebration
                    alert(`Congratulations! You've achieved a ${milestone}-day streak!`);
                    
                    saveData();
                }
            });
        }

        // Render badges for milestones
        function renderBadges() {
            badgesContainer.innerHTML = '';
            
            if (habitData.user.streak >= 3) {
                const streakBadge = document.createElement('div');
                streakBadge.className = 'streak-badge';
                streakBadge.innerHTML = `<i class="fas fa-fire"></i> ${habitData.user.streak} Day Streak`;
                badgesContainer.appendChild(streakBadge);
            }
            
            habitData.user.milestones.forEach(milestone => {
                const milestoneBadge = document.createElement('div');
                milestoneBadge.className = 'milestone-badge';
                milestoneBadge.innerHTML = `<i class="fas fa-medal"></i> ${milestone} Days`;
                badgesContainer.appendChild(milestoneBadge);
            });
        }

        // Display a random motivational quote
        function displayRandomQuote() {
            const randomIndex = Math.floor(Math.random() * motivationalQuotes.length);
            motivationQuoteElement.textContent = motivationalQuotes[randomIndex];
        }

        // Handle complete day action
        function completeDay() {
            // Open reflection modal first
            openReflectionModal();
        }

        // Complete day action after reflection
        function completeAfterReflection() {
            // Update streak
            habitData.user.streak += 1;
            habitData.user.lastActive = new Date().toLocaleDateString();
            
            // Hide all completed goals
            const completedGoals = document.querySelectorAll('.goal-completed');
            completedGoals.forEach(goal => {
                goal.classList.add('hide-completed');
            });
            
            // Record daily progress
            const today = new Date().toLocaleDateString();
            habitData.user.dailyHistory[today] = {
                score: habitData.user.score,
                goalsCompleted: document.querySelectorAll('.goal-completed').length,
                tasksCompleted: document.querySelectorAll('.subtask-checkbox:checked').length
            };
            
            // Check for milestones
            checkStreak();
            renderBadges();
            
            // Celebration for completing the day
            showConfetti(40); // Increased from 15 to 40 for an impressive daily completion celebration
            
            saveData();
            renderGoals(); // Re-render to hide completed goals
            
            alert('Great job completing your goals today! Come back tomorrow for new challenges.');
        }

        // Handle prepare tomorrow action
        function prepareTomorrow() {
            if (confirm('Are you ready to set up tomorrow\'s goals? This will clear today\'s progress.')) {
                // Keep the streak and score, but reset goals
                habitData.goals = [];
                habitData.goals.bonusAwarded = false;
                
                saveData();
                renderGoals();
                
                // Open add goal modal to start setting up tomorrow
                openAddGoalModal();
                
                alert('Ready to set your goals for tomorrow!');
            }
        }

        // Open add goal modal
        function openAddGoalModal() {
            addGoalModal.style.display = 'flex';
            goalTitleInput.focus();
        }

        // Close add goal modal
        function closeAddGoalModalFn() {
            addGoalModal.style.display = 'none';
            goalTitleInput.value = '';
        }

        // Open add subtask modal
        function openAddSubtaskModal(goalId) {
            addSubtaskModal.style.display = 'flex';
            currentGoalIdInput.value = goalId;
            subtaskTitleInput.focus();
        }

        // Close add subtask modal
        function closeAddSubtaskModalFn() {
            addSubtaskModal.style.display = 'none';
            subtaskTitleInput.value = '';
            subtaskTimeInput.value = '';
            if (subtaskDifficultyInput) subtaskDifficultyInput.value = 'easy';
            if (subtaskSubjectInput) subtaskSubjectInput.value = '';
            if (subtaskLectureInput) subtaskLectureInput.value = '';
            if (subtaskNotesInput) subtaskNotesInput.value = '';
        }

        // Event Listeners
        addGoalBtn.addEventListener('click', openAddGoalModal);
        closeGoalModal.addEventListener('click', closeAddGoalModalFn);

        saveGoalBtn.addEventListener('click', () => {
            const title = goalTitleInput.value.trim();
            if (title) {
                addGoal(title);
                closeAddGoalModalFn();
            } else {
                alert('Please enter a goal title');
            }
        });

        closeSubtaskModal.addEventListener('click', closeAddSubtaskModalFn);

        saveSubtaskBtn.addEventListener('click', () => {
            const title = subtaskTitleInput.value.trim();
            const time = subtaskTimeInput.value.trim();
            const difficulty = subtaskDifficultyInput.value;
            const subject = subtaskSubjectInput.value.trim();
            const lecture = subtaskLectureInput.value.trim();
            const notes = subtaskNotesInput ? subtaskNotesInput.value.trim() : '';
            const goalId = parseInt(currentGoalIdInput.value);
            
            if (title) {
                addSubtask(goalId, title, time, difficulty, subject, lecture, notes);
                closeAddSubtaskModalFn();
            } else {
                alert('Please enter a subtask title');
            }
        });

        completeDayBtn.addEventListener('click', completeDay);
        prepareTomorrowBtn.addEventListener('click', prepareTomorrow);

        startHabitTrackerBtn.addEventListener('click', () => {
            welcomeModal.style.display = 'none';
            openAddGoalModal();
        });

        // Handle enter key in input fields
        goalTitleInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                saveGoalBtn.click();
            }
        });

        subtaskTitleInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                saveSubtaskBtn.click();
            }
        });

        // Setup auto-completion at 11:59 PM
        function setupAutoComplete() {
            // Check current time and schedule auto-completion if needed
            const now = new Date();
            const endOfDay = new Date(
                now.getFullYear(),
                now.getMonth(),
                now.getDate(),
                23,
                59,
                0
            );
            
            const timeUntilEndOfDay = endOfDay - now;
            
            if (timeUntilEndOfDay > 0) {
                setTimeout(() => {
                    // Auto-complete the day if not already completed
                    if (habitData.goals.length > 0) {
                        autoCompleteDay();
                    }
                }, timeUntilEndOfDay);
            }
        }

        // Auto-complete day function
        function autoCompleteDay() {
            console.log("Auto-completing day at 11:59 PM");
            
            // Save current day's progress to history
            saveToHistory();
            
            // Apply penalties for incomplete tasks
            applyIncompletePenalties();
            
            // Set last active to today
            habitData.user.lastActive = new Date().toISOString();
            
            // Update streak
            habitData.user.streak++;
            
            // Check for milestones
            checkStreak();
            renderBadges();
            
            saveData();
            
            // If the user is still active, show a notification
            if (document.visibilityState === 'visible') {
                alert('Day automatically completed! Your progress has been saved.');
            }
        }

        // Apply penalties for incomplete tasks
        function applyIncompletePenalties() {
            let incompleteCount = 0;
            let exerciseIncomplete = false;
            let exercisePenalty = 0;
            
            habitData.goals.forEach(goal => {
                goal.subtasks.forEach(subtask => {
                    if (!subtask.completed) {
                        incompleteCount++;
                        
                        // Check if it's the exercise task
                        if (subtask.isBonus && subtask.bonusType === "exercise") {
                            exerciseIncomplete = true;
                            exercisePenalty = 10; // Special 10-point penalty for exercise
                        }
                    }
                });
            });
            
            const regularPenalty = incompleteCount * 2; // 2 points per incomplete task (including exercise)
            const totalPenalty = regularPenalty + exercisePenalty - 2; // Subtract 2 points from total since exercise is counted twice (in regularPenalty and exercisePenalty)
            
            if (totalPenalty > 0) {
                habitData.user.score -= totalPenalty;
                if (habitData.user.score < 0) habitData.user.score = 0;
                
                // Show alert for exercise penalty
                if (exerciseIncomplete) {
                    alert(`You've received an additional 10-point penalty for not completing the Exercise task!`);
                }
                
                // Store penalty info in history
                const today = new Date().toISOString().split('T')[0];
                if (!habitData.user.dailyHistory[today]) {
                    habitData.user.dailyHistory[today] = {
                        goals: JSON.parse(JSON.stringify(habitData.goals)),
                        penalty: totalPenalty,
                        exercisePenalty: exercisePenalty > 0 ? exercisePenalty : 0,
                        score: habitData.user.score
                    };
                } else {
                    habitData.user.dailyHistory[today].penalty = totalPenalty;
                    habitData.user.dailyHistory[today].exercisePenalty = exercisePenalty > 0 ? exercisePenalty : 0;
                    habitData.user.dailyHistory[today].score = habitData.user.score;
                }
            }
        }

        // Save current goals to history
        function saveToHistory() {
            const today = new Date().toISOString().split('T')[0];
            
            // Get reflection if exists
            const reflection = habitData.user.reflections[today] || null;
            
            // Deep clone the goals to store in history
            habitData.user.dailyHistory[today] = {
                goals: JSON.parse(JSON.stringify(habitData.goals)),
                score: habitData.user.score,
                penalty: 0,
                reflection: reflection,
                completedAt: new Date().toISOString()
            };
            
            saveData();
        }

        // Initialize history section
        function initializeHistory() {
            // Toggle history section when header is clicked
            historyHeader.addEventListener('click', () => {
                historyHeader.classList.toggle('expanded');
                historyContent.style.display = historyContent.style.display === 'block' ? 'none' : 'block';
                
                if (historyContent.style.display === 'block') {
                    renderHistory();
                }
            });
        }

        // Render history content
        function renderHistory() {
            historyContent.innerHTML = '';
            
            // Add date picker to jump to specific date
            const datePicker = document.createElement('div');
            datePicker.className = 'history-datepicker';
            
            const dateInput = document.createElement('input');
            dateInput.type = 'date';
            dateInput.id = 'historyDatePicker';
            
            const jumpButton = document.createElement('button');
            jumpButton.textContent = 'Jump to Date';
            jumpButton.addEventListener('click', () => {
                const selectedDate = document.getElementById('historyDatePicker').value;
                if (selectedDate) {
                    jumpToDate(selectedDate);
                }
            });
            
            datePicker.appendChild(dateInput);
            datePicker.appendChild(jumpButton);
            historyContent.appendChild(datePicker);
            
            // Get dates from history sorted by most recent
            const dates = Object.keys(habitData.user.dailyHistory).sort().reverse();
            
            if (dates.length === 0) {
                const emptyMsg = document.createElement('p');
                emptyMsg.textContent = 'No history data available yet.';
                historyContent.appendChild(emptyMsg);
                return;
            }
            
            // Group dates by day of the week
            const dayGroups = {};
            const daysOfWeek = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
            
            dates.forEach(dateStr => {
                const date = new Date(dateStr);
                const dayOfWeek = daysOfWeek[date.getDay()];
                
                if (!dayGroups[dayOfWeek]) {
                    dayGroups[dayOfWeek] = [];
                }
                
                dayGroups[dayOfWeek].push(dateStr);
            });
            
            // Create sections for each day of the week
            daysOfWeek.forEach(day => {
                if (dayGroups[day] && dayGroups[day].length > 0) {
                    const daySection = document.createElement('div');
                    daySection.className = 'history-day';
                    
                    const dayHeader = document.createElement('div');
                    dayHeader.className = 'history-day-header';
                    dayHeader.innerHTML = `<span>${day} (${dayGroups[day].length})</span><i class="fas fa-chevron-down"></i>`;
                    
                    const dayContent = document.createElement('div');
                    dayContent.className = 'history-day-content';
                    dayContent.style.display = 'none';
                    
                    dayHeader.addEventListener('click', () => {
                        dayContent.style.display = dayContent.style.display === 'none' ? 'block' : 'none';
                        dayHeader.querySelector('i').className = dayContent.style.display === 'none' ? 
                            'fas fa-chevron-down' : 'fas fa-chevron-up';
                    });
                    
                    // Add dates for this day
                    dayGroups[day].forEach(dateStr => {
                        const dateData = habitData.user.dailyHistory[dateStr];
                        const formattedDate = new Date(dateStr).toLocaleDateString();
                        
                        const dateEntry = document.createElement('div');
                        dateEntry.className = 'history-date';
                        
                        const dateHeader = document.createElement('div');
                        dateHeader.className = 'history-date-header';
                        dateHeader.innerHTML = `
                            <strong>${formattedDate}</strong> - Score: ${dateData.score}
                            ${dateData.completedAt ? `<span style="color: var(--success); margin-left: 10px;"><i class="fas fa-check-circle"></i> Completed</span>` : ''}
                        `;
                        
                        if (dateData.penalty > 0) {
                            dateHeader.innerHTML += ` <span style="color: var(--danger);">(Penalty: -${dateData.penalty})</span>`;
                        }
                        
                        dateEntry.appendChild(dateHeader);
                        
                        // Add reflection if exists
                        if (dateData.reflection) {
                            const reflectionEntry = document.createElement('div');
                            reflectionEntry.className = 'history-reflection';
                            reflectionEntry.style.padding = '10px';
                            reflectionEntry.style.backgroundColor = 'rgba(76, 201, 240, 0.1)';
                            reflectionEntry.style.borderRadius = '8px';
                            reflectionEntry.style.margin = '10px 0';
                            
                            const moodIcons = {
                                'great': 'ðŸ˜„',
                                'good': 'ðŸ™‚',
                                'okay': 'ðŸ˜',
                                'bad': 'ðŸ˜•',
                                'terrible': 'ðŸ˜ž'
                            };
                            
                            reflectionEntry.innerHTML = `
                                <div><strong>Mood:</strong> ${moodIcons[dateData.reflection.mood]} ${dateData.reflection.mood}</div>
                                <div><strong>Reflection:</strong> ${dateData.reflection.text}</div>
                                <div><strong>Focus for next day:</strong> ${dateData.reflection.tomorrowFocus}</div>
                            `;
                            
                            dateEntry.appendChild(reflectionEntry);
                        }
                        
                        // Add goals and subtasks
                        if (dateData.goals && dateData.goals.length > 0) {
                            const goalsContainer = document.createElement('div');
                            goalsContainer.className = 'history-goals-container';
                            goalsContainer.style.margin = '10px 0';
                            
                            dateData.goals.forEach(goal => {
                                const goalEntry = document.createElement('div');
                                goalEntry.className = 'history-goal';
                                goalEntry.style.background = 'rgba(255, 255, 255, 0.05)';
                                goalEntry.style.borderRadius = '8px';
                                goalEntry.style.padding = '10px';
                                goalEntry.style.marginBottom = '10px';
                                
                                const goalHeader = document.createElement('div');
                                goalHeader.style.display = 'flex';
                                goalHeader.style.justifyContent = 'space-between';
                                goalHeader.style.alignItems = 'center';
                                goalHeader.style.marginBottom = '10px';
                                
                                const goalTitle = document.createElement('h4');
                                goalTitle.style.margin = '0';
                                goalTitle.textContent = goal.title;
                                
                                const goalStatus = document.createElement('span');
                                if (goal.completed) {
                                    goalStatus.innerHTML = '<i class="fas fa-check-circle" style="color: var(--success);"></i> Completed';
                                    goalStatus.style.color = 'var(--success)';
                                } else {
                                    goalStatus.innerHTML = '<i class="fas fa-times-circle" style="color: var(--danger);"></i> Incomplete';
                                    goalStatus.style.color = 'var(--danger)';
                                }
                                
                                goalHeader.appendChild(goalTitle);
                                goalHeader.appendChild(goalStatus);
                                goalEntry.appendChild(goalHeader);
                                
                                if (goal.subtasks && goal.subtasks.length > 0) {
                                    const subtasksList = document.createElement('ul');
                                    subtasksList.className = 'history-subtasks';
                                    subtasksList.style.listStyle = 'none';
                                    subtasksList.style.padding = '0';
                                    subtasksList.style.margin = '0';
                                    
                                    goal.subtasks.forEach(subtask => {
                                        const subtaskItem = document.createElement('li');
                                        subtaskItem.className = `history-task ${subtask.completed ? 'completed' : 'incomplete'}`;
                                        subtaskItem.style.padding = '8px';
                                        subtaskItem.style.display = 'flex';
                                        subtaskItem.style.justifyContent = 'space-between';
                                        subtaskItem.style.alignItems = 'center';
                                        subtaskItem.style.borderBottom = '1px solid rgba(255, 255, 255, 0.1)';
                                        
                                        const subtaskContent = document.createElement('div');
                                        
                                        const subtaskTitle = document.createElement('span');
                                        subtaskTitle.textContent = subtask.title;
                                        if (subtask.completed) {
                                            subtaskTitle.style.textDecoration = 'line-through';
                                            subtaskTitle.style.opacity = '0.7';
                                        }
                                        
                                        subtaskContent.appendChild(subtaskTitle);
                                        
                                        if (subtask.time) {
                                            const subtaskTime = document.createElement('small');
                                            subtaskTime.textContent = ` (${subtask.time})`;
                                            subtaskTime.style.color = '#aaa';
                                            subtaskTime.style.marginLeft = '5px';
                                            subtaskContent.appendChild(subtaskTime);
                                        }
                                        
                                        const subtaskStatus = document.createElement('span');
                                        subtaskStatus.textContent = subtask.completed ? 'âœ“' : 'âœ—';
                                        subtaskStatus.style.color = subtask.completed ? 'var(--success)' : 'var(--danger)';
                                        subtaskStatus.style.fontWeight = 'bold';
                                        
                                        subtaskItem.appendChild(subtaskContent);
                                        subtaskItem.appendChild(subtaskStatus);
                                        
                                        subtasksList.appendChild(subtaskItem);
                                    });
                                    
                                    goalEntry.appendChild(subtasksList);
                                } else {
                                    const noSubtasks = document.createElement('p');
                                    noSubtasks.textContent = 'No subtasks for this goal.';
                                    noSubtasks.style.fontStyle = 'italic';
                                    noSubtasks.style.color = '#aaa';
                                    goalEntry.appendChild(noSubtasks);
                                }
                                
                                goalsContainer.appendChild(goalEntry);
                            });
                            
                            dateEntry.appendChild(goalsContainer);
                        } else {
                            const noGoals = document.createElement('p');
                            noGoals.textContent = 'No goals for this day.';
                            dateEntry.appendChild(noGoals);
                        }
                        
                        dayContent.appendChild(dateEntry);
                    });
                    
                    daySection.appendChild(dayHeader);
                    daySection.appendChild(dayContent);
                    historyContent.appendChild(daySection);
                }
            });
        }

        // Jump to specific date in history
        function jumpToDate(dateStr) {
            if (habitData.user.dailyHistory[dateStr]) {
                // Expand all sections to make the date visible
                const dayElements = document.querySelectorAll('.history-day-content');
                dayElements.forEach(el => {
                    el.style.display = 'block';
                });
                
                // Find the date element and scroll to it
                const dateElements = document.querySelectorAll('.history-date-header');
                const targetDate = new Date(dateStr).toLocaleDateString();
                
                for (let i = 0; i < dateElements.length; i++) {
                    if (dateElements[i].textContent.includes(targetDate)) {
                        dateElements[i].scrollIntoView({ behavior: 'smooth', block: 'start' });
                        
                        // Highlight the element temporarily
                        dateElements[i].style.backgroundColor = 'rgba(247, 37, 133, 0.2)';
                        setTimeout(() => {
                            dateElements[i].style.backgroundColor = 'transparent';
                        }, 2000);
                        
                        break;
                    }
                }
            } else {
                alert('No data available for the selected date.');
            }
        }

        // Handle reset button
        function setupResetButton() {
            // Make sure all required elements are defined
            const resetProgressBtn = document.getElementById('resetProgressBtn');
            const resetConfirmationModal = document.getElementById('resetConfirmationModal');
            const closeResetModal = document.getElementById('closeResetModal');
            const resetConfirmInput = document.getElementById('resetConfirmInput');
            const confirmResetBtn = document.getElementById('confirmResetBtn');
            
            if (!resetProgressBtn || !resetConfirmationModal || !closeResetModal || !resetConfirmInput || !confirmResetBtn) {
                console.error('Reset button elements not found!');
                return;
            }
            
            resetProgressBtn.addEventListener('click', () => {
                console.log('Reset button clicked');
                resetConfirmationModal.style.display = 'flex';
                resetConfirmInput.value = ''; // Clear any previous input
            });
            
            closeResetModal.addEventListener('click', () => {
                resetConfirmationModal.style.display = 'none';
                resetConfirmInput.value = '';
            });
            
            confirmResetBtn.addEventListener('click', () => {
                console.log('Confirm reset clicked. Input value:', resetConfirmInput.value);
                if (resetConfirmInput.value === 'CONFIRM') {
                    resetAllProgress();
                    resetConfirmationModal.style.display = 'none';
                    resetConfirmInput.value = '';
                    
                    // Reload page to ensure all UI elements are reset properly
                    window.location.reload();
                } else {
                    alert('Please type CONFIRM (all caps) to reset progress');
                }
            });
            
            // Also handle enter key press in the input field
            resetConfirmInput.addEventListener('keyup', (e) => {
                if (e.key === 'Enter') {
                    if (resetConfirmInput.value === 'CONFIRM') {
                        resetAllProgress();
                        resetConfirmationModal.style.display = 'none';
                        resetConfirmInput.value = '';
                        
                        // Reload page to ensure all UI elements are reset properly
                        window.location.reload();
                    } else {
                        alert('Please type CONFIRM (all caps) to reset progress');
                    }
                }
            });
            
            console.log('Reset button setup complete');
        }

        // Reset all progress
        function resetAllProgress() {
            // Create a backup of the settings (to preserve themes, etc.)
            const settingsCopy = { ...habitData.settings };
            
            // Reset the data structure
            habitData = {
                user: {
                    name: "You",
                    score: 0,
                    streak: 0,
                    lastActive: null,
                    history: [],
                    milestones: [],
                    dailyHistory: {},
                    reflections: {}
                },
                goals: [],
                competitors: [
                    { name: "Alex", score: 50, history: [], intensity: "medium" },
                    { name: "Jamie", score: 35, history: [], intensity: "medium" },
                    { name: "Taylor", score: 30, history: [], intensity: "medium" },
                    { name: "Morgan", score: 25, history: [], intensity: "medium" },
                    { name: "Casey", score: 100, history: [], intensity: "hard" }
                ],
                settings: settingsCopy, // Preserve settings
                customQuotes: [],
                lastReset: new Date().toLocaleDateString()
            };
            
            // Save the reset data
            saveData();
            
            // Generate sample history for the chart
            generateSampleHistory();
            
            // Update all UI components
            renderGoals();
            updateLeaderboard();
            renderBadges();
            
            // Recreate the chart
            if (chart) {
                chart.destroy();
            }
            initChart();
            
            alert('All progress has been reset!');
        }

        // Add the automatic exercise subtask
        function addExerciseSubtask(goalId) {
            const goalIndex = habitData.goals.findIndex(goal => goal.id === goalId);
            
            const exerciseSubtask = {
                id: Date.now(),
                title: "Exercise",
                time: "1 hour", // Changed from 30 mins to 1 hour
                completed: false,
                isBonus: true, // Flag to prevent deletion
                bonusType: "exercise",
                difficulty: "easy", // Default difficulty
                isExerciseRequired: true // New flag to indicate this is a mandatory task
            };
            
            habitData.goals[goalIndex].subtasks.push(exerciseSubtask);
            saveData();
        }

        // Add the bonus reading subtask
        function addReadingSubtask(goalId) {
            const goalIndex = habitData.goals.findIndex(goal => goal.id === goalId);
            
            const readingSubtask = {
                id: Date.now() + 1, // Ensure unique ID
                title: "Reading",
                time: "30 mins",
                completed: false,
                isBonus: true, // Flag to prevent deletion
                bonusType: "reading",
                difficulty: "medium" // Default difficulty
            };
            
            habitData.goals[goalIndex].subtasks.push(readingSubtask);
            saveData();
        }

        // Add the bonus revising subtask
        function addRevisingSubtask(goalId) {
            const goalIndex = habitData.goals.findIndex(goal => goal.id === goalId);
            
            const revisingSubtask = {
                id: Date.now() + 2, // Ensure unique ID
                title: "Revising",
                time: "45 mins",
                completed: false,
                isBonus: true, // Flag to prevent deletion
                bonusType: "revising",
                difficulty: "hard" // Default difficulty
            };
            
            habitData.goals[goalIndex].subtasks.push(revisingSubtask);
            saveData();
        }

        // Add the bonus practicing subtask
        function addPracticingSubtask(goalId) {
            const goalIndex = habitData.goals.findIndex(goal => goal.id === goalId);
            
            const practicingSubtask = {
                id: Date.now() + 3, // Ensure unique ID
                title: "Practicing",
                time: "1 hour",
                completed: false,
                isBonus: true, // Flag to prevent deletion
                bonusType: "practicing",
                difficulty: "medium" // Default difficulty
            };
            
            habitData.goals[goalIndex].subtasks.push(practicingSubtask);
            saveData();
        }

        // Initialize the app when the page loads
        window.addEventListener('DOMContentLoaded', () => {
            initApp();
            setupResetButton();
            setupCompetitorCustomization();
            setupDataOptions();
            setupSettingsPanel();
            setupAnalytics();
            loadSettings();
            
            // Start periodic leaderboard updates
            startLeaderboardUpdates();
        });

        // Timer functionality
        const timerModal = document.getElementById('timerModal');
        const closeTimerModal = document.getElementById('closeTimerModal');
        const timerMinutes = document.getElementById('timerMinutes');
        const timerSeconds = document.getElementById('timerSeconds');
        const timerTaskName = document.getElementById('timerTaskName');
        const startTimerBtn = document.getElementById('startTimerBtn');
        const pauseTimerBtn = document.getElementById('pauseTimerBtn');
        const resetTimerBtn = document.getElementById('resetTimerBtn');
        const pomodoroWork = document.getElementById('pomodoroWork');
        const pomodoroBreak = document.getElementById('pomodoroBreak');
        const pomodoroCycles = document.getElementById('pomodoroCycles');
        const pomodoroLongBreak = document.getElementById('pomodoroLongBreak');
        const pomodoroProgress = document.getElementById('pomodoroProgress');
        const pomodoroProgressBar = document.getElementById('pomodoroProgressBar');

        let timer;
        let timerRunning = false;
        let timerMode = 'work'; // Can be 'work', 'break', or 'longBreak'
        let pomodoroCurrentCycle = 0;
        let totalSeconds = 0;
        let currentGoalIdForTimer;
        let currentSubtaskIdForTimer;

        // Open timer modal
        function openTimer(goalId, subtaskId) {
            currentGoalIdForTimer = goalId;
            currentSubtaskIdForTimer = subtaskId;
            
            // Get subtask info
            const goal = habitData.goals.find(g => g.id === goalId);
            const subtask = goal.subtasks.find(s => s.id === subtaskId);
            
            timerTaskName.textContent = subtask.title;
            
            // Reset timer to work time
            const workMinutes = parseInt(pomodoroWork.value);
            totalSeconds = workMinutes * 60;
            timerMinutes.textContent = workMinutes < 10 ? '0' + workMinutes : workMinutes;
            timerSeconds.textContent = '00';
            
            // Reset buttons
            startTimerBtn.disabled = false;
            pauseTimerBtn.disabled = true;
            
            // Show modal
            timerModal.style.display = 'flex';
        }

        // Close timer modal
        closeTimerModal.addEventListener('click', () => {
            timerModal.style.display = 'none';
            if (timerRunning) {
                clearInterval(timer);
                timerRunning = false;
            }
        });

        // Start timer
        startTimerBtn.addEventListener('click', () => {
            if (!timerRunning) {
                timerRunning = true;
                startTimerBtn.disabled = true;
                pauseTimerBtn.disabled = false;
                
                timer = setInterval(updateTimer, 1000);
            }
        });

        // Pause timer
        pauseTimerBtn.addEventListener('click', () => {
            if (timerRunning) {
                clearInterval(timer);
                timerRunning = false;
                startTimerBtn.disabled = false;
                pauseTimerBtn.disabled = true;
            }
        });

        // Reset timer
        resetTimerBtn.addEventListener('click', () => {
            clearInterval(timer);
            timerRunning = false;
            
            // Reset to work time
            if (timerMode === 'work') {
                const workMinutes = parseInt(pomodoroWork.value);
                totalSeconds = workMinutes * 60;
                timerMinutes.textContent = workMinutes < 10 ? '0' + workMinutes : workMinutes;
            } else if (timerMode === 'break') {
                const breakMinutes = parseInt(pomodoroBreak.value);
                totalSeconds = breakMinutes * 60;
                timerMinutes.textContent = breakMinutes < 10 ? '0' + breakMinutes : breakMinutes;
            } else {
                const longBreakMinutes = parseInt(pomodoroLongBreak.value);
                totalSeconds = longBreakMinutes * 60;
                timerMinutes.textContent = longBreakMinutes < 10 ? '0' + longBreakMinutes : longBreakMinutes;
            }
            
            timerSeconds.textContent = '00';
            startTimerBtn.disabled = false;
            pauseTimerBtn.disabled = true;
        });

        // Update timer every second
        function updateTimer() {
            totalSeconds--;
            
            if (totalSeconds < 0) {
                clearInterval(timer);
                
                // Handle cycle completion
                if (timerMode === 'work') {
                    pomodoroCurrentCycle++;
                    const totalCycles = parseInt(pomodoroCycles.value);
                    
                    // Update progress
                    pomodoroProgress.textContent = `${pomodoroCurrentCycle}/${totalCycles}`;
                    pomodoroProgressBar.style.width = `${(pomodoroCurrentCycle / totalCycles) * 100}%`;
                    
                    // Auto-complete task if work cycle completed
                    if (currentGoalIdForTimer && currentSubtaskIdForTimer) {
                        const goal = habitData.goals.find(g => g.id === currentGoalIdForTimer);
                        const subtask = goal.subtasks.find(s => s.id === currentSubtaskIdForTimer);
                        
                        if (!subtask.completed) {
                            toggleSubtask(currentGoalIdForTimer, currentSubtaskIdForTimer);
                        }
                    }
                    
                    // Check if we need a long break
                    if (pomodoroCurrentCycle % totalCycles === 0) {
                        timerMode = 'longBreak';
                        totalSeconds = parseInt(pomodoroLongBreak.value) * 60;
                        alert('Work cycle complete! Time for a long break.');
                        
                        // Update leaderboard when a work cycle completes
                        updateLeaderboard();
                    } else {
                        timerMode = 'break';
                        totalSeconds = parseInt(pomodoroBreak.value) * 60;
                        alert('Work cycle complete! Time for a short break.');
                        
                        // Update leaderboard when a work cycle completes
                        updateLeaderboard();
                    }
                } else {
                    // Break time finished, back to work
                    timerMode = 'work';
                    totalSeconds = parseInt(pomodoroWork.value) * 60;
                    alert(timerMode === 'longBreak' ? 'Long break over! Back to work.' : 'Break over! Back to work.');
                }
                
                // Reset timers
                timerRunning = false;
                startTimerBtn.disabled = false;
                pauseTimerBtn.disabled = true;
                
                // Update display
                const minutes = Math.floor(totalSeconds / 60);
                const seconds = totalSeconds % 60;
                
                timerMinutes.textContent = minutes < 10 ? '0' + minutes : minutes;
                timerSeconds.textContent = seconds < 10 ? '0' + seconds : seconds;
                
                // Play sound notification
                const notification = new Audio('https://assets.mixkit.co/sfx/preview/mixkit-alarm-digital-clock-beep-989.mp3');
                notification.play();
                
                return;
            }
            
            // Update display
            const minutes = Math.floor(totalSeconds / 60);
            const seconds = totalSeconds % 60;
            
            timerMinutes.textContent = minutes < 10 ? '0' + minutes : minutes;
            timerSeconds.textContent = seconds < 10 ? '0' + seconds : seconds;
        }

        // Competitor customization
        const competitorModal = document.getElementById('competitorModal');
        const closeCompetitorModal = document.getElementById('closeCompetitorModal');
        const customizeCompetitorsBtn = document.getElementById('customizeCompetitors');
        const competitorsList = document.getElementById('competitorsList');
        const newCompetitorName = document.getElementById('newCompetitorName');
        const newCompetitorIntensity = document.getElementById('newCompetitorIntensity');
        const addCompetitorBtn = document.getElementById('addCompetitorBtn');

        // Setup competitor customization
        function setupCompetitorCustomization() {
            customizeCompetitorsBtn.addEventListener('click', openCompetitorModal);
            closeCompetitorModal.addEventListener('click', closeCompetitorModalFn);
            addCompetitorBtn.addEventListener('click', addNewCompetitor);
            
            // Real-time update for competitor changes
            setInterval(() => {
                // Only update if modal is open
                if (competitorModal.style.display === 'flex') {
                    renderCompetitorsList();
                }
            }, 3000); // Update every 3 seconds
        }

        // Open competitor modal
        function openCompetitorModal() {
            renderCompetitorsList();
            competitorModal.style.display = 'flex';
        }

        // Close competitor modal
        function closeCompetitorModalFn() {
            competitorModal.style.display = 'none';
            newCompetitorName.value = '';
        }

        // Render competitors list
        function renderCompetitorsList() {
            competitorsList.innerHTML = '';
            
            // Add a header section with instructions
            const headerSection = document.createElement('div');
            headerSection.style.marginBottom = '20px';
            headerSection.innerHTML = `
                <h4 style="margin-bottom: 10px;">Customize Your Competitors</h4>
                <p style="margin-bottom: 15px;">Adjust competitor intensity levels and change their graph colors.</p>
                <button id="resetCompetitorsBtn" class="btn btn-danger" style="width: 100%;">
                    <i class="fas fa-undo"></i> Reset All Competitors
                </button>
            `;
            competitorsList.appendChild(headerSection);
            
            // Add reset button functionality
            const resetCompetitorsBtn = headerSection.querySelector('#resetCompetitorsBtn');
            resetCompetitorsBtn.addEventListener('click', () => {
                if (confirm('Are you sure you want to reset all competitors to default settings? This cannot be undone.')) {
                    // Reset competitors to default
                    habitData.competitors = [
                        { name: "Alex", score: 50, history: [], intensity: "medium", color: getRandomColor() },
                        { name: "Jamie", score: 35, history: [], intensity: "medium", color: getRandomColor() },
                        { name: "Taylor", score: 30, history: [], intensity: "medium", color: getRandomColor() },
                        { name: "Morgan", score: 25, history: [], intensity: "medium", color: getRandomColor() },
                        { name: "Casey", score: 100, history: [], intensity: "hard", color: getRandomColor() }
                    ];
                    saveData();
                    renderCompetitorsList();
                    updateLeaderboard();
                    
                    // Recreate chart with new colors
                    if (chart) {
                        chart.destroy();
                    }
                    initChart();
                    
                    alert('Competitors have been reset to default settings.');
                }
            });

            habitData.competitors.forEach((competitor, index) => {
                const competitorItem = document.createElement('div');
                competitorItem.className = 'competitor-item';
                competitorItem.style.display = 'flex';
                competitorItem.style.flexDirection = 'column';
                competitorItem.style.padding = '15px';
                competitorItem.style.borderBottom = '1px solid #eee';
                competitorItem.style.marginBottom = '15px';
                competitorItem.style.background = 'rgba(255, 255, 255, 0.05)';
                competitorItem.style.borderRadius = '10px';

                // Top row with competitor info and actions
                const topRow = document.createElement('div');
                topRow.style.display = 'flex';
                topRow.style.justifyContent = 'space-between';
                topRow.style.alignItems = 'center';
                topRow.style.marginBottom = '10px';
                
                const competitorInfo = document.createElement('div');
                
                const competitorName = document.createElement('span');
                competitorName.textContent = competitor.name;
                competitorName.style.fontWeight = '600';
                competitorName.style.fontSize = '1.1rem';
                
                // Add REAL-TIME label and update score in real-time
                const competitorScore = document.createElement('span');
                competitorScore.innerHTML = ` - <span class="real-time-score" style="position: relative;">${competitor.score} points <span style="position: absolute; top: -8px; right: -40px; font-size: 0.6rem; background: var(--success); color: white; padding: 2px 4px; border-radius: 3px;">LIVE</span></span>`;
                competitorScore.style.color = '#6c757d';
                
                // Fix the duplicate intensityLabel - rename this one to intensityTag
                const intensityTag = document.createElement('span');
                intensityTag.textContent = ` (${competitor.intensity || 'medium'})`;
                intensityTag.style.fontSize = '0.8rem';
                intensityTag.style.color = competitor.intensity === 'hard' ? '#e63946' : 
                                           competitor.intensity === 'easy' ? '#4cc9f0' : '#fca311';
                
                competitorInfo.appendChild(competitorName);
                competitorInfo.appendChild(competitorScore);
                competitorInfo.appendChild(intensityTag);
                
                const competitorActions = document.createElement('div');
                competitorActions.style.display = 'flex';
                competitorActions.style.gap = '10px';
                
                const deleteButton = document.createElement('button');
                deleteButton.className = 'btn btn-danger';
                deleteButton.innerHTML = '<i class="fas fa-trash"></i>';
                deleteButton.style.padding = '5px 10px';
                deleteButton.addEventListener('click', () => {
                    deleteCompetitor(index);
                });
                
                competitorActions.appendChild(deleteButton);
                
                topRow.appendChild(competitorInfo);
                topRow.appendChild(competitorActions);
                
                // Settings row
                const settingsRow = document.createElement('div');
                settingsRow.style.display = 'grid';
                settingsRow.style.gridTemplateColumns = '1fr 1fr';
                settingsRow.style.gap = '10px';
                settingsRow.style.marginTop = '10px';
                
                // Intensity selector
                const intensityContainer = document.createElement('div');
                intensityContainer.style.display = 'flex';
                intensityContainer.style.flexDirection = 'column';
                
                const intensityLabel = document.createElement('label');
                intensityLabel.textContent = 'Intensity Level:';
                intensityLabel.style.marginBottom = '5px';
                intensityLabel.style.fontSize = '0.9rem';
                
                const intensitySelect = document.createElement('select');
                intensitySelect.className = 'form-input';
                intensitySelect.style.padding = '8px';
                
                const easyOption = document.createElement('option');
                easyOption.value = 'easy';
                easyOption.textContent = 'Easy';
                easyOption.selected = competitor.intensity === 'easy';
                
                const mediumOption = document.createElement('option');
                mediumOption.value = 'medium';
                mediumOption.textContent = 'Medium';
                mediumOption.selected = !competitor.intensity || competitor.intensity === 'medium';
                
                const hardOption = document.createElement('option');
                hardOption.value = 'hard';
                hardOption.textContent = 'Hard';
                hardOption.selected = competitor.intensity === 'hard';
                
                intensitySelect.appendChild(easyOption);
                intensitySelect.appendChild(mediumOption);
                intensitySelect.appendChild(hardOption);
                
                intensitySelect.addEventListener('change', () => {
                    changeCompetitorIntensity(index, intensitySelect.value);
                });
                
                intensityContainer.appendChild(intensityLabel);
                intensityContainer.appendChild(intensitySelect);
                
                // Color picker
                const colorContainer = document.createElement('div');
                colorContainer.style.display = 'flex';
                colorContainer.style.flexDirection = 'column';
                
                const colorLabel = document.createElement('label');
                colorLabel.textContent = 'Graph Line Color:';
                colorLabel.style.marginBottom = '5px';
                colorLabel.style.fontSize = '0.9rem';
                
                const colorInput = document.createElement('input');
                colorInput.type = 'color';
                colorInput.className = 'form-input';
                colorInput.value = competitor.color || getRandomColor();
                colorInput.style.padding = '0';
                colorInput.style.height = '38px';
                
                colorInput.addEventListener('change', () => {
                    changeCompetitorColor(index, colorInput.value);
                });
                
                colorContainer.appendChild(colorLabel);
                colorContainer.appendChild(colorInput);
                
                settingsRow.appendChild(intensityContainer);
                settingsRow.appendChild(colorContainer);
                
                competitorItem.appendChild(topRow);
                competitorItem.appendChild(settingsRow);
                
                competitorsList.appendChild(competitorItem);
                
                // Add a pulse animation to the real-time score
                const realTimeScoreElement = competitorItem.querySelector('.real-time-score');
                realTimeScoreElement.style.transition = 'transform 0.2s';
                
                // Random score updates to simulate real-time changes
                setTimeout(() => {
                    const scoreChange = Math.floor(Math.random() * 3) - 1; // -1, 0, or 1
                    if (scoreChange !== 0) {
                        competitor.score += scoreChange;
                        realTimeScoreElement.innerHTML = `${competitor.score} points <span style="position: absolute; top: -8px; right: -40px; font-size: 0.6rem; background: var(--success); color: white; padding: 2px 4px; border-radius: 3px;">LIVE</span>`;
                        realTimeScoreElement.style.transform = 'scale(1.1)';
                        setTimeout(() => {
                            realTimeScoreElement.style.transform = 'scale(1)';
                        }, 200);
                        saveData();
                    }
                }, Math.random() * 2000); // Random time within the next 2 seconds
            });
        }

        // Add new competitor
        function addNewCompetitor() {
            const name = newCompetitorName.value.trim();
            const intensity = newCompetitorIntensity.value;
            
            if (!name) {
                alert('Please enter a competitor name');
                return;
            }
            
            habitData.competitors.push({
                name: name,
                score: calculateInitialScore(intensity),
                intensity: intensity,
                history: []
            });
            
            saveData();
            renderCompetitorsList();
            updateLeaderboard();
            
            newCompetitorName.value = '';
        }

        // Calculate initial score based on intensity
        function calculateInitialScore(intensity) {
            if (intensity === 'easy') {
                return Math.max(10, habitData.user.score - 15); // Ensure minimum of 10 points
            } else if (intensity === 'medium') {
                return Math.max(20, habitData.user.score + Math.floor(Math.random() * 10) - 5); // Smaller random range
            } else {
                return Math.max(30, habitData.user.score + 10 + Math.floor(Math.random() * 15)); // Higher minimum
            }
        }

        // Change competitor intensity
        function changeCompetitorIntensity(index, intensity) {
            habitData.competitors[index].intensity = intensity;
            
            // Adjust score based on new intensity - ensure positive values with reasonable differences
            if (intensity === 'easy') {
                habitData.competitors[index].score = Math.max(10, habitData.user.score - 15);
            } else if (intensity === 'medium') {
                habitData.competitors[index].score = Math.max(20, habitData.user.score + Math.floor(Math.random() * 10) - 5);
            } else {
                habitData.competitors[index].score = Math.max(30, habitData.user.score + 10 + Math.floor(Math.random() * 15));
            }
            
            saveData();
            renderCompetitorsList();
            updateLeaderboard();
        }

        // Delete competitor
        function deleteCompetitor(index) {
            if (confirm(`Are you sure you want to remove ${habitData.competitors[index].name} from the competition?`)) {
                habitData.competitors.splice(index, 1);
                saveData();
                renderCompetitorsList();
                updateLeaderboard();
            }
        }

        // Modify updateLeaderboard to respect competitor intensity
        function updateLeaderboard() {
            const leaderboardList = document.getElementById('leaderboardList');

            // Keep track of previous positions for animation effects
            const previousPositions = {};
            const previousScores = {};
            
            // Store previous positions and scores before updating
            Array.from(leaderboardList.children).forEach(item => {
                const name = item.querySelector('.leaderboard-name').textContent.trim().replace(' (You)', '');
                const rankElement = item.querySelector('.leaderboard-rank');
                const scoreElement = item.querySelector('.leaderboard-score');
                
                previousPositions[name] = parseInt(rankElement.textContent);
                previousScores[name] = parseInt(scoreElement.textContent);
            });
            
            // Clear the leaderboard
            leaderboardList.innerHTML = '';
            
            // Create a combined array of competitors and the user
            const allCompetitors = [...habitData.competitors];
            allCompetitors.push({
                name: "You",
                score: habitData.user.score,
                isUser: true
            });
            
            // Sort by score
            allCompetitors.sort((a, b) => b.score - a.score);
            
            // Handle competitor intensity
            for (let i = 0; i < allCompetitors.length; i++) {
                const competitor = allCompetitors[i];
                if (!competitor.isUser && competitor.intensity) {
                    if (competitor.intensity === 'hard') {
                        // Hard competitors always stay ahead of you, but not by too much
                        if (competitor.score <= habitData.user.score) {
                            competitor.score = Math.max(30, habitData.user.score + Math.ceil(Math.random() * 3) + 2);
                        } else if (competitor.score > habitData.user.score + 25) {
                            // Cap the maximum lead to keep it achievable
                            competitor.score = habitData.user.score + 15 + Math.floor(Math.random() * 10);
                        }
                    } else if (competitor.intensity === 'medium') {
                        // Medium competitors stay competitive but beatable
                        if (competitor.score > habitData.user.score + 7) {
                            competitor.score = habitData.user.score + Math.floor(Math.random() * 5) + 2;
                        } else if (competitor.score < habitData.user.score - 7) {
                            competitor.score = Math.max(15, habitData.user.score - Math.floor(Math.random() * 5) - 2);
                        }
                    } else if (competitor.intensity === 'easy') {
                        // Easy competitors always stay behind but not by too much
                        if (competitor.score >= habitData.user.score) {
                            competitor.score = Math.max(10, habitData.user.score - Math.ceil(Math.random() * 3) - 2);
                        } else if (competitor.score < habitData.user.score - 20) {
                            // Don't let them fall too far behind
                            competitor.score = habitData.user.score - 10 - Math.floor(Math.random() * 5);
                        }
                    }
                    
                    // Ensure no negative scores
                    competitor.score = Math.max(1, competitor.score);
                }
            }
            
            // Re-sort after adjusting scores
            allCompetitors.sort((a, b) => b.score - a.score);
            
            // Add items to the leaderboard
            allCompetitors.forEach((competitor, index) => {
                const rank = index + 1;
                const listItem = document.createElement('li');
                listItem.className = 'leaderboard-item';
                
                if (competitor.isUser) {
                    listItem.classList.add('user-entry');
                }
                
                // Position change detection
                const previousPosition = previousPositions[competitor.isUser ? 'You' : competitor.name] || null;
                const previousScore = previousScores[competitor.isUser ? 'You' : competitor.name] || competitor.score;
                
                if (previousPosition && previousPosition !== rank) {
                    if (previousPosition > rank) {
                        listItem.classList.add('position-change-up');
                    } else {
                        listItem.classList.add('position-change-down');
                    }
                }
                
                // Create rank element with appropriate styling
                const rankElement = document.createElement('div');
                rankElement.className = 'leaderboard-rank';
                
                if (rank === 1) {
                    rankElement.classList.add('rank-1');
                } else if (rank === 2) {
                    rankElement.classList.add('rank-2');
                } else if (rank === 3) {
                    rankElement.classList.add('rank-3');
                } else {
                    rankElement.classList.add('rank-other');
                }
                
                rankElement.textContent = rank;
                
                // Create name element
                const nameElement = document.createElement('div');
                nameElement.className = 'leaderboard-name';
                
                // Add appropriate rank-based color class to the name
                if (rank === 1) {
                    nameElement.classList.add('rank-1-name');
                } else if (rank === 2) {
                    nameElement.classList.add('rank-2-name');
                } else if (rank === 3) {
                    nameElement.classList.add('rank-3-name');
                } else if (rank <= 10) {
                    nameElement.classList.add(`rank-${rank}-name`);
                } else {
                    nameElement.classList.add('rank-other-name');
                }
                
                // Add crown icon for first place
                if (rank === 1) {
                    const crownIcon = document.createElement('span');
                    crownIcon.className = 'crown-icon';
                    crownIcon.innerHTML = '<i class="fas fa-crown"></i>';
                    nameElement.appendChild(crownIcon);
                }
                
                // Add name text
                const nameText = document.createTextNode(competitor.isUser ? 'You' : competitor.name);
                nameElement.appendChild(nameText);
                
                // Add 'You' indicator for user
                if (competitor.isUser) {
                    const userIndicator = document.createElement('span');
                    userIndicator.className = 'user-indicator';
                    userIndicator.textContent = 'YOU';
                    nameElement.appendChild(userIndicator);
                }
                
                // Add position change indicator if applicable
                if (previousPosition && previousPosition !== rank) {
                    const changeIndicator = document.createElement('span');
                    changeIndicator.className = 'position-change-indicator';
                    
                    if (previousPosition > rank) {
                        changeIndicator.classList.add('position-up');
                        changeIndicator.innerHTML = `<i class="fas fa-arrow-up"></i> ${previousPosition - rank}`;
                    } else {
                        changeIndicator.classList.add('position-down');
                        changeIndicator.innerHTML = `<i class="fas fa-arrow-down"></i> ${rank - previousPosition}`;
                    }
                    
                    nameElement.appendChild(changeIndicator);
                }
                
                // Create score element
                const scoreElement = document.createElement('div');
                scoreElement.className = 'leaderboard-score';
                scoreElement.textContent = competitor.score;
                
                // Add score change indicator if applicable
                if (previousScore !== competitor.score) {
                    const scoreChange = document.createElement('div');
                    scoreChange.className = 'score-change';
                    
                    if (previousScore < competitor.score) {
                        scoreChange.classList.add('score-increase');
                        scoreChange.innerHTML = `<i class="fas fa-plus"></i>${competitor.score - previousScore}`;
                    } else if (previousScore > competitor.score) {
                        scoreChange.classList.add('score-decrease');
                        scoreChange.innerHTML = `<i class="fas fa-minus"></i>${previousScore - competitor.score}`;
                    }
                    
                    scoreElement.appendChild(scoreChange);
                }
                
                // Add progress bar
                const progressContainer = document.createElement('div');
                progressContainer.className = 'progress-bar-container';
                
                const progressBar = document.createElement('div');
                progressBar.className = 'progress-bar';
                
                progressContainer.appendChild(progressBar);
                
                // Append all elements to the list item
                listItem.appendChild(rankElement);
                listItem.appendChild(nameElement);
                listItem.appendChild(scoreElement);
                listItem.appendChild(progressContainer);
                
                // Add to leaderboard
                leaderboardList.appendChild(listItem);
                
                // Animate the progress bar based on relative score
                setTimeout(() => {
                    const maxScore = allCompetitors[0].score;
                    const percentage = (competitor.score / maxScore) * 100;
                    progressBar.style.width = `${percentage}%`;
                }, 100);
            });
            
            // Add fancy entrance animations
            Array.from(leaderboardList.children).forEach((item, index) => {
                item.style.opacity = '0';
                item.style.transform = 'translateY(20px)';
                setTimeout(() => {
                    item.style.transition = 'opacity 0.5s ease, transform 0.5s ease';
                    item.style.opacity = '1';
                    item.style.transform = 'translateY(0)';
                }, 50 * index);
            });
        }

        // Data export/import functionality
        const exportDataBtn = document.getElementById('exportDataBtn');
        const importDataBtn = document.getElementById('importDataBtn');
        const importDataModal = document.getElementById('importDataModal');
        const closeImportModal = document.getElementById('closeImportModal');
        const importDataText = document.getElementById('importDataText');
        const confirmImportBtn = document.getElementById('confirmImportBtn');

        // Setup data options
        function setupDataOptions() {
            // Export data
            exportDataBtn.addEventListener('click', exportData);

            // Import data
            importDataBtn.addEventListener('click', openImportModal);
            closeImportModal.addEventListener('click', () => {
                importDataModal.style.display = 'none';
            });
            confirmImportBtn.addEventListener('click', importData);
        }

        // Export data to JSON file
        function exportData() {
            // Create a JSON string from the habitData
            const dataStr = JSON.stringify(habitData, null, 2);
            
            // Create a download link
            const dataUri = 'data:application/json;charset=utf-8,'+ encodeURIComponent(dataStr);
            
            const exportFileDefaultName = `habit_tracker_backup_${new Date().toISOString().split('T')[0]}.json`;
            
            const linkElement = document.createElement('a');
            linkElement.setAttribute('href', dataUri);
            linkElement.setAttribute('download', exportFileDefaultName);
            linkElement.click();
            
            // Close dropdown
            dropdownContent.style.display = 'none';
        }

        // Open import modal
        function openImportModal() {
            importDataModal.style.display = 'flex';
            importDataText.value = '';
            
            // Close dropdown
            dropdownContent.style.display = 'none';
        }

        // Import data from JSON
        function importData() {
            try {
                const importedData = JSON.parse(importDataText.value);
                
                // Validate data structure
                if (!importedData.user || !importedData.goals || !importedData.competitors) {
                    throw new Error('Invalid data structure');
                }
                
                // Confirm import
                if (confirm('Are you sure you want to import this data? Current data will be replaced.')) {
                    habitData = importedData;
                    saveData();
                    
                    // Refresh the app
                    renderGoals();
                    updateLeaderboard();
                    renderBadges();
                    
                    if (chart) {
                        chart.destroy();
                    }
                    initChart();
                    
                    // Close modal
                    importDataModal.style.display = 'none';
                    
                    alert('Data imported successfully!');
                }
            } catch (error) {
                alert('Error importing data: ' + error.message);
            }
        }

        // Export data to CSV format
        function exportDataToCsv() {
            let csvContent = "data:text/csv;charset=utf-8,";
            
            // Add headers
            csvContent += "Date,Goal,Subtask,Completed,Difficulty,Points\n";
            
            // Add data from history
            for (const [dateStr, dayData] of Object.entries(habitData.user.dailyHistory)) {
                dayData.goals.forEach(goal => {
                    goal.subtasks.forEach(subtask => {
                        const row = [
                            dateStr,
                            goal.title,
                            subtask.title,
                            subtask.completed ? "Yes" : "No",
                            subtask.difficulty || "medium",
                            subtask.completed ? (subtask.difficulty === "easy" ? 5 : subtask.difficulty === "medium" ? 10 : 15) : 0
                        ];
                        csvContent += row.join(",") + "\n";
                    });
                });
            }
            
            // Create download link
            const encodedUri = encodeURI(csvContent);
            const link = document.createElement("a");
            link.setAttribute("href", encodedUri);
            link.setAttribute("download", `habit_tracker_data_${new Date().toISOString().split('T')[0]}.csv`);
            document.body.appendChild(link);
            link.click();
        }

        // Daily Reflection functionality
        const reflectionModal = document.getElementById('reflectionModal');
        const closeReflectionModal = document.getElementById('closeReflectionModal');
        const reflectionDate = document.getElementById('reflectionDate');
        const reflectionMood = document.getElementById('reflectionMood');
        const reflectionText = document.getElementById('reflectionText');
        const tomorrowFocus = document.getElementById('tomorrowFocus');
        const saveReflectionBtn = document.getElementById('saveReflectionBtn');

        // Initialize reflections if not exist
        if (!habitData.user.reflections) {
            habitData.user.reflections = {};
        }

        // Handle complete day action with reflection
        function completeDay() {
            // Open reflection modal first
            openReflectionModal();
        }

        // Open reflection modal
        function openReflectionModal() {
            // Set today's date
            const today = new Date().toISOString().split('T')[0];
            reflectionDate.value = today;
            
            // Check if we already have a reflection for today
            if (habitData.user.reflections && habitData.user.reflections[today]) {
                reflectionMood.value = habitData.user.reflections[today].mood;
                reflectionText.value = habitData.user.reflections[today].text;
                tomorrowFocus.value = habitData.user.reflections[today].tomorrowFocus;
            } else {
                reflectionMood.value = 'good';
                reflectionText.value = '';
                tomorrowFocus.value = '';
            }
            
            reflectionModal.style.display = 'flex';
        }

        // Close reflection modal
        closeReflectionModal.addEventListener('click', () => {
            reflectionModal.style.display = 'none';
        });

        // Save reflection and complete day
        saveReflectionBtn.addEventListener('click', () => {
            const today = new Date().toISOString().split('T')[0];
            
            // Save reflection
            habitData.user.reflections[today] = {
                mood: reflectionMood.value,
                text: reflectionText.value,
                tomorrowFocus: tomorrowFocus.value,
                date: today
            };
            
            // Now complete the day
            completeAfterReflection();
            
            // Close modal
            reflectionModal.style.display = 'none';
        });

        // The actual process of completing the day (moved from completeDay)
        function completeAfterReflection() {
                // Update streak
                habitData.user.streak++;
                
                // Check for milestones
                checkStreak();
                renderBadges();
                
                // Celebration for completing the day
            showConfetti(40); // Increased from 15 to 40 for an impressive daily completion celebration
                
                saveData();
                renderGoals(); // Re-render to hide completed goals
                
                alert('Great job completing your goals today! Come back tomorrow for new challenges.');
        }

        // Settings functionality
        const settingsBtn = document.getElementById('settingsBtn');
        const settingsPanel = document.getElementById('settingsPanel');
        const closeSettings = document.getElementById('closeSettings');
        const themeOptions = document.querySelectorAll('.theme-option');
        const fontOptions = document.querySelectorAll('.font-option');
        const autoCompleteToggle = document.getElementById('autoCompleteToggle');
        const soundToggle = document.getElementById('soundToggle');
        const confettiToggle = document.getElementById('confettiToggle');
        const defaultWorkTime = document.getElementById('defaultWorkTime');
        const defaultBreakTime = document.getElementById('defaultBreakTime');

        // Initialize settings object if not exists
        if (!habitData.settings) {
            habitData.settings = {
                theme: 'default',
                font: 'sans',
                autoComplete: true,
                soundNotifications: true,
                confettiEffects: true,
                defaultWorkTime: 25,
                defaultBreakTime: 5
            };
            saveData();
        }

        // Load settings from stored data
        function loadSettings() {
            // Set theme
            document.body.className = habitData.settings.theme !== 'default' ? 
                `theme-${habitData.settings.theme}` : '';
            
            // Apply dark mode if saved
            applyDarkModeIfSaved();
            
            // Update theme selector
            themeOptions.forEach(option => {
                option.classList.remove('active');
                if (option.dataset.theme === habitData.settings.theme) {
                    option.classList.add('active');
                }
            });
            
            // Set font
            document.body.classList.add(`font-${habitData.settings.font}`);
            
            // Update font selector
            fontOptions.forEach(option => {
                option.classList.remove('active');
                if (option.dataset.font === habitData.settings.font) {
                    option.classList.add('active');
                }
            });
            
            // Set toggles
            autoCompleteToggle.checked = habitData.settings.autoComplete;
            soundToggle.checked = habitData.settings.soundNotifications;
            confettiToggle.checked = habitData.settings.confettiEffects;
            
            // Set timer defaults
            defaultWorkTime.value = habitData.settings.defaultWorkTime;
            defaultBreakTime.value = habitData.settings.defaultBreakTime;
            
            // Update pomodoro settings
            pomodoroWork.value = habitData.settings.defaultWorkTime;
            pomodoroBreak.value = habitData.settings.defaultBreakTime;
        }

        // Setup settings panel
        function setupSettingsPanel() {
            // Open settings panel
            settingsBtn.addEventListener('click', () => {
                settingsPanel.classList.add('open');
            });
            
            // Close settings panel
            closeSettings.addEventListener('click', () => {
                settingsPanel.classList.remove('open');
            });
            
            // Theme options
            themeOptions.forEach(option => {
                option.addEventListener('click', () => {
                    // Remove previous theme
                    document.body.className = '';
                    
                    // Add new theme
                    const theme = option.dataset.theme;
                    if (theme !== 'default') {
                        document.body.classList.add(`theme-${theme}`);
                    }
                    
                    // Add font back
                    document.body.classList.add(`font-${habitData.settings.font}`);
                    
                    // Update active state
                    themeOptions.forEach(opt => opt.classList.remove('active'));
                    option.classList.add('active');
                    
                    // Save settings
                    habitData.settings.theme = theme;
                    saveData();
                });
            });
            
            // Font options
            fontOptions.forEach(option => {
                option.addEventListener('click', () => {
                    // Remove previous font classes
                    document.body.classList.remove('font-sans', 'font-serif', 'font-mono');
                    
                    // Add new font
                    const font = option.dataset.font;
                    document.body.classList.add(`font-${font}`);
                    
                    // Update active state
                    fontOptions.forEach(opt => opt.classList.remove('active'));
                    option.classList.add('active');
                    
                    // Save settings
                    habitData.settings.font = font;
                    saveData();
                });
            });
            
            // Toggle settings
            autoCompleteToggle.addEventListener('change', () => {
                habitData.settings.autoComplete = autoCompleteToggle.checked;
                saveData();
            });
            
            soundToggle.addEventListener('change', () => {
                habitData.settings.soundNotifications = soundToggle.checked;
                saveData();
            });
            
            confettiToggle.addEventListener('change', () => {
                habitData.settings.confettiEffects = confettiToggle.checked;
                saveData();
            });
            
            // Timer settings
            defaultWorkTime.addEventListener('change', () => {
                habitData.settings.defaultWorkTime = parseInt(defaultWorkTime.value);
                saveData();
            });
            
            defaultBreakTime.addEventListener('change', () => {
                habitData.settings.defaultBreakTime = parseInt(defaultBreakTime.value);
                saveData();
            });
        }

        // Update showConfetti function to respect settings
        function showConfetti(count) {
            // Only show if effects are enabled
            if (!habitData.settings.confettiEffects) return;
            
            confettiContainer.style.display = 'block';
            
            for (let i = 0; i < count * 25; i++) {
                const confetti = document.createElement('div');
                confetti.className = 'confetti';
                
                // Random color
                const colors = ['#f72585', '#4361ee', '#4cc9f0', '#7209b7', '#560bad', '#fca311'];
                confetti.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
                
                // Random position
                confetti.style.left = Math.random() * 100 + 'vw';
                
                // Random size
                const size = (Math.random() * 10) + 5;
                confetti.style.width = size + 'px';
                confetti.style.height = size + 'px';
                
                // Random rotation
                confetti.style.animationDuration = (Math.random() * 2) + 2 + 's';
                
                // Random animation
                const animations = ['sparkle', 'spin', 'scale', 'sway'];
                confetti.style.animationName = animations[Math.floor(Math.random() * animations.length)];
                
                // Random shape
                const shapes = ['circle', 'square', 'triangle', 'rectangle', 'star'];
                confetti.classList.add(shapes[Math.floor(Math.random() * shapes.length)]);
                
                // Random delay
                confetti.style.animationDelay = Math.random() * 3 + 's';
                
                confettiContainer.appendChild(confetti);
                
                // Remove after animation completes
                setTimeout(() => {
                    confetti.remove();
                }, 3000);
            }
            
            // Hide container when all animations are done
            setTimeout(() => {
                confettiContainer.style.display = 'none';
            }, 3500);
        }

        // Update the timer sound notification
        function playNotificationSound() {
            if (habitData.settings.soundNotifications) {
                const notification = new Audio('https://assets.mixkit.co/sfx/preview/mixkit-alarm-digital-clock-beep-989.mp3');
                notification.play();
            }
        }

        // Modify setupAutoComplete to respect settings
        function setupAutoComplete() {
            // Only setup if auto-complete is enabled
            if (!habitData.settings.autoComplete) return;
            
            // Check current time and schedule auto-completion if needed
            const now = new Date();
            const endOfDay = new Date(
                now.getFullYear(),
                now.getMonth(),
                now.getDate(),
                23,
                59,
                0
            );
            
            const timeUntilEndOfDay = endOfDay - now;
            
            if (timeUntilEndOfDay > 0) {
                setTimeout(() => {
                    // Auto-complete the day if not already completed
                    if (habitData.goals.length > 0) {
                        autoCompleteDay();
                    }
                }, timeUntilEndOfDay);
            }
        }

        // Enhanced analytics
        let tasksDonutChart;
        let weeklyChart;
        let trendsChart;

        // Setup analytics
        function setupAnalytics() {
            // Setup tab switching
            const statsTabs = document.querySelectorAll('.stats-tab');
            const statsContents = document.querySelectorAll('.stats-content');
            
            statsTabs.forEach(tab => {
                tab.addEventListener('click', () => {
                    const tabId = tab.dataset.tab;
                    
                    // Update active tab
                    statsTabs.forEach(t => t.classList.remove('active'));
                    tab.classList.add('active');
                    
                    // Show selected content, hide others
                    statsContents.forEach(content => {
                        content.style.display = 'none';
                        if (content.id === `stats-${tabId}`) {
                            content.style.display = 'block';
                        }
                    });
                    
                    // Initialize charts if needed
                    if (tabId === 'daily' && !tasksDonutChart) {
                        initTasksDonutChart();
                    } else if (tabId === 'weekly' && !weeklyChart) {
                        initWeeklyChart();
                    } else if (tabId === 'trends' && !trendsChart) {
                        initTrendsChart();
                    }
                });
            });
            
            // Initialize summary stats
            updateSummaryStats();
        }

        // Update summary statistics
        function updateSummaryStats() {
            // Update total points
            document.getElementById('stats-total-points').textContent = habitData.user.score;
            
            // Update current streak
            document.getElementById('stats-current-streak').textContent = `${habitData.user.streak} days`;
            
            // Count total tasks and completed tasks
            let totalTasks = 0;
            let completedTasks = 0;
            
            // Count tasks from history
            for (const dayData of Object.values(habitData.user.dailyHistory)) {
                dayData.goals.forEach(goal => {
                    totalTasks += goal.subtasks.length;
                    completedTasks += goal.subtasks.filter(subtask => subtask.completed).length;
                });
            }
            
            // Add current tasks
            habitData.goals.forEach(goal => {
                totalTasks += goal.subtasks.length;
                completedTasks += goal.subtasks.filter(subtask => subtask.completed).length;
            });
            
            document.getElementById('stats-total-tasks').textContent = totalTasks;
            
            // Calculate completion rate
            const completionRate = totalTasks > 0 ? Math.round((completedTasks / totalTasks) * 100) : 0;
            document.getElementById('stats-completion-rate').textContent = `${completionRate}%`;
            
            // Update daily progress
            updateDailyProgress();
        }

        // Update daily progress
        function updateDailyProgress() {
            const dailyGoal = habitData.settings && habitData.settings.dailyPointsGoal ? 
                             habitData.settings.dailyPointsGoal : 50; // Default to 50 if not set
            const todayPoints = habitData.user.score;
            const progressPercent = Math.min(100, Math.round((todayPoints / dailyGoal) * 100));
            
            document.getElementById('today-progress').style.width = `${progressPercent}%`;
            document.getElementById('today-points').textContent = todayPoints;
            document.getElementById('daily-goal').textContent = dailyGoal;
        }

        // Initialize tasks donut chart
        function initTasksDonutChart() {
            const ctx = document.getElementById('tasksDonutChart').getContext('2d');
            
            // Count completed and pending tasks for today
            let completedTasks = 0;
            let pendingTasks = 0;
            
            habitData.goals.forEach(goal => {
                completedTasks += goal.subtasks.filter(subtask => subtask.completed).length;
                pendingTasks += goal.subtasks.filter(subtask => !subtask.completed).length;
            });
            
            // Create donut chart
            tasksDonutChart = new Chart(ctx, {
                type: 'doughnut',
                data: {
                    labels: ['Completed', 'Pending'],
                    datasets: [{
                        data: [completedTasks, pendingTasks],
                        backgroundColor: [
                            'rgba(76, 201, 240, 0.7)',
                            'rgba(247, 37, 133, 0.7)'
                        ],
                        borderColor: [
                            'rgba(76, 201, 240, 1)',
                            'rgba(247, 37, 133, 1)'
                        ],
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    plugins: {
                        legend: {
                            position: 'bottom'
                        }
                    },
                    cutout: '70%'
                }
            });
        }

        // Initialize weekly chart
        function initWeeklyChart() {
            const ctx = document.getElementById('weeklyChart').getContext('2d');
            
            // Get last 7 days data
            const days = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
            const today = new Date();
            const dailyScores = Array(7).fill(0);
            let mostProductiveDay = -1;
            let highestScore = -1;
            
            // Fill with data from history
            for (const [dateStr, dayData] of Object.entries(habitData.user.dailyHistory)) {
                const date = new Date(dateStr);
                const daysAgo = Math.floor((today - date) / (1000 * 60 * 60 * 24));
                
                if (daysAgo < 7) {
                    const dayOfWeek = date.getDay();
                    dailyScores[dayOfWeek] = dayData.score;
                    
                    if (dayData.score > highestScore) {
                        highestScore = dayData.score;
                        mostProductiveDay = dayOfWeek;
                    }
                }
            }
            
            // If today has points but not in history yet
            if (habitData.user.score > 0) {
                const dayOfWeek = today.getDay();
                dailyScores[dayOfWeek] = habitData.user.score;
                
                if (habitData.user.score > highestScore) {
                    highestScore = habitData.user.score;
                    mostProductiveDay = dayOfWeek;
                }
            }
            
            // Create weekly chart
            weeklyChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: days,
                    datasets: [{
                        label: 'Points',
                        data: dailyScores,
                        backgroundColor: 'rgba(67, 97, 238, 0.7)',
                        borderColor: 'rgba(67, 97, 238, 1)',
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    scales: {
                        y: {
                            beginAtZero: true
                        }
                    }
                }
            });
            
            // Update most productive day
            document.getElementById('most-productive-day').textContent = 
                mostProductiveDay >= 0 ? `${days[mostProductiveDay]} (${highestScore} points)` : 'Not enough data';
            
            // Calculate weekly average
            const activedays = dailyScores.filter(score => score > 0).length;
            const totalPoints = dailyScores.reduce((a, b) => a + b, 0);
            const average = activedays > 0 ? Math.round(totalPoints / activedays) : 0;
            
            document.getElementById('weekly-average').textContent = `${average} points/day`;
        }

        // Initialize trends chart
        function initTrendsChart() {
            const ctx = document.getElementById('trendsChart').getContext('2d');
            
            // Get daily history for the last 30 days
            const today = new Date();
            const lastMonth = [];
            
            for (let i = 29; i >= 0; i--) {
                const date = new Date();
                date.setDate(today.getDate() - i);
                const dateStr = date.toISOString().split('T')[0];
                
                if (habitData.user.dailyHistory[dateStr]) {
                    lastMonth.push(habitData.user.dailyHistory[dateStr].score);
                } else if (i === 0 && habitData.user.score > 0) {
                    // Today's score if not in history yet
                    lastMonth.push(habitData.user.score);
                } else {
                    lastMonth.push(0);
                }
            }
            
            // Calculate trend line (simple linear regression)
            const trendData = calculateTrendLine(lastMonth);
            
            // Create trends chart
            trendsChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: Array.from({length: lastMonth.length}, (_, i) => `Day ${i+1}`),
                    datasets: [
                        {
                            label: 'Daily Points',
                            data: lastMonth,
                            borderColor: 'rgba(76, 201, 240, 1)',
                            backgroundColor: 'rgba(76, 201, 240, 0.1)',
                            fill: true,
                            tension: 0.4
                        },
                        {
                            label: 'Trend',
                            data: trendData,
                            borderColor: 'rgba(247, 37, 133, 1)',
                            borderDash: [5, 5],
                            fill: false,
                            pointRadius: 0
                        }
                    ]
                },
                options: {
                    responsive: true,
                    scales: {
                        y: {
                            beginAtZero: true
                        }
                    }
                }
            });
            
            // Update trend insights
            updateTrendInsights(lastMonth, trendData);
        }

        // Calculate trend line using simple linear regression
        function calculateTrendLine(data) {
            const n = data.length;
            
            // If not enough data, return flat line
            if (n < 3) {
                return data;
            }
            
            let sumX = 0;
            let sumY = 0;
            let sumXY = 0;
            let sumXX = 0;
            
            // Calculate sums needed for linear regression
            for (let i = 0; i < n; i++) {
                sumX += i;
                sumY += data[i];
                sumXY += i * data[i];
                sumXX += i * i;
            }
            
            // Calculate slope and y-intercept
            const slope = (n * sumXY - sumX * sumY) / (n * sumXX - sumX * sumX);
            const intercept = (sumY - slope * sumX) / n;
            
            // Generate trend line data
            const trendData = [];
            for (let i = 0; i < n; i++) {
                trendData.push(slope * i + intercept);
            }
            
            return trendData;
        }

        // Update trend insights
        function updateTrendInsights(data, trendData) {
            // Determine performance trend
            const start = trendData[0];
            const end = trendData[trendData.length - 1];
            let trend = 'Stable';
            
            if (end > start * 1.1) {
                trend = 'Improving ðŸ“ˆ';
            } else if (end < start * 0.9) {
                trend = 'Declining ðŸ“‰';
            } else {
                trend = 'Stable ðŸ“Š';
            }
            
            document.getElementById('performance-trend').textContent = trend;
            
            // Calculate consistency score
            const activedays = data.filter(score => score > 0).length;
            const consistencyScore = Math.round((activedays / data.length) * 100);
            
            document.getElementById('consistency-score').textContent = `${consistencyScore}%`;
        }

        // Update analytics when data changes
        function updateAnalytics() {
            updateSummaryStats();
            
            // Update charts if they exist
            if (tasksDonutChart) {
                tasksDonutChart.destroy();
                initTasksDonutChart();
            }
            
            if (weeklyChart) {
                weeklyChart.destroy();
                initWeeklyChart();
            }
            
            if (trendsChart) {
                trendsChart.destroy();
                initTrendsChart();
            }
        }

        // Add graph customization variables and functions
        let chartColors = {
            userLine: '#f72585',
            background: 'rgba(255, 255, 255, 0.9)',
            showGridLines: true
        };

        // Add these elements to the DOM references
        const userLineColor = document.getElementById('userLineColor');
        const graphBackgroundColor = document.getElementById('graphBackgroundColor');
        const showGridLines = document.getElementById('showGridLines');
        const applyGraphSettings = document.getElementById('applyGraphSettings');
        const dailyPointsGoal = document.getElementById('dailyPointsGoal');

        // Setup real-time updates
        function setupRealTimeUpdates() {
            // Set interval for real-time leaderboard and graph updates
            setInterval(() => {
                updateLeaderboard();
                updateAnalytics();
            }, 15000); // Update every 15 seconds
        }

        // Customize the daily points goal
        function updateDailyGoal() {
            const goal = parseInt(dailyPointsGoal.value);
            
            // Update the daily goal displayed in the stats
            document.getElementById('daily-goal').textContent = goal;
            
            // Update progress percentage based on new goal
            const todayPoints = habitData.user.score;
            const progressPercent = Math.min(100, Math.round((todayPoints / goal) * 100));
            document.getElementById('today-progress').style.width = `${progressPercent}%`;
            
            // Save to settings
            if (!habitData.settings) {
                habitData.settings = {};
            }
            habitData.settings.dailyPointsGoal = goal;
            saveData();
        }

        // Setup graph customization
        function setupGraphCustomization() {
            // Initialize with saved settings if available
            if (habitData.settings && habitData.settings.chartColors) {
                chartColors = habitData.settings.chartColors;
                userLineColor.value = chartColors.userLine;
                graphBackgroundColor.value = chartColors.background;
                showGridLines.checked = chartColors.showGridLines;
            }
            
            // Initialize with saved daily points goal if available
            if (habitData.settings && habitData.settings.dailyPointsGoal) {
                dailyPointsGoal.value = habitData.settings.dailyPointsGoal;
                document.getElementById('daily-goal').textContent = habitData.settings.dailyPointsGoal;
            }
            
            // Apply changes button click
            applyGraphSettings.addEventListener('click', () => {
                // Update color settings
                chartColors.userLine = userLineColor.value;
                chartColors.background = graphBackgroundColor.value;
                chartColors.showGridLines = showGridLines.checked;
                
                // Save settings
                if (!habitData.settings) {
                    habitData.settings = {};
                }
                habitData.settings.chartColors = chartColors;
                saveData();
                
                // Recreate the chart with new settings
                if (chart) {
                    chart.destroy();
                }
                initChart();
                
                // Show confirmation
                alert('Graph settings updated!');
            });
            
            // Daily points goal change
            dailyPointsGoal.addEventListener('change', updateDailyGoal);
        }

        // Dark mode toggle functionality
        const darkModeToggle = document.getElementById('darkModeToggle');
        
        darkModeToggle.addEventListener('click', () => {
            toggleDarkMode();
        });

        // Function to toggle dark mode
        function toggleDarkMode() {
            // If currently in dark mode and toggling to light mode
            if (document.body.classList.contains('dark-mode')) {
                // Remove dark mode class
                document.body.classList.remove('dark-mode');
                darkModeToggle.classList.remove('active');
                
                // Also switch to default theme
                document.body.className = ''; // Clear all theme classes
                
                // Add font class back
                if (habitData.settings && habitData.settings.font) {
                    document.body.classList.add(`font-${habitData.settings.font}`);
                }
                
                // Update theme settings
                if (habitData.settings) {
                    habitData.settings.darkMode = false;
                    habitData.settings.theme = 'default';
                } else {
                    habitData.settings = { darkMode: false, theme: 'default' };
                }
                
                // Update light mode button text
                darkModeToggle.innerHTML = '<i class="fas fa-moon"></i> Dark Mode';
                
                // Update theme options visually
                document.querySelectorAll('.theme-option').forEach(opt => opt.classList.remove('active'));
                const defaultThemeOption = document.querySelector('.theme-option.theme-default');
                if (defaultThemeOption) {
                    defaultThemeOption.classList.add('active');
                }
            } else {
                // Toggling to dark mode
                document.body.classList.add('dark-mode');
                darkModeToggle.classList.add('active');
                darkModeToggle.innerHTML = '<i class="fas fa-sun"></i> Light Mode';
                
                // Save dark mode setting
                if (habitData.settings) {
                    habitData.settings.darkMode = true;
                } else {
                    habitData.settings = { darkMode: true };
                }
                
                // Update theme option
                const darkThemeOption = document.querySelector('.theme-option.theme-dark');
                if (darkThemeOption) {
                    document.querySelectorAll('.theme-option').forEach(opt => opt.classList.remove('active'));
                    darkThemeOption.classList.add('active');
                }
            }
            
            // Update analysis modal theme if it exists
            if (typeof applyThemeToAnalysisModal === 'function') {
                applyThemeToAnalysisModal();
            }
            
            // Update other modal themes
            applyThemeToModals();
            
            // Save settings
            saveData();
        }
        
        // Apply theme to all modals
        function applyThemeToModals() {
            // Update timer modal
            const timerModal = document.getElementById('timerModal');
            if (timerModal) {
                // Refresh timer display colors
                const timerDisplay = timerModal.querySelector('.timer-display');
                if (timerDisplay) {
                    if (document.body.classList.contains('dark-mode')) {
                        timerDisplay.style.background = 'var(--primary)';
                    } else {
                        timerDisplay.style.background = 'var(--primary-light)';
                    }
                }
            }
            
            // Update competitor modal
            const competitorModal = document.getElementById('competitorModal');
            if (competitorModal) {
                // Refresh competitor items
                const competitors = competitorModal.querySelectorAll('.competitor-item');
                competitors.forEach(item => {
                    item.style.borderBottomColor = 'rgba(255, 255, 255, 0.1)';
                });
            }
        }
        
        // Apply dark mode on load if it was set previously
        function applyDarkModeIfSaved() {
            if (habitData.settings && habitData.settings.darkMode) {
                document.body.classList.add('dark-mode');
                darkModeToggle.classList.add('active');
                darkModeToggle.innerHTML = '<i class="fas fa-sun"></i> Light Mode';
            }
        }
        
        // Update loadSettings to apply dark mode
        function loadSettings() {
            // Set theme
            document.body.className = habitData.settings.theme !== 'default' ? 
                `theme-${habitData.settings.theme}` : '';
            
            // Apply dark mode if saved
            applyDarkModeIfSaved();
            
            // Rest of the function remains the same...
            // Update theme selector
            themeOptions.forEach(option => {
                option.classList.remove('active');
                if (option.dataset.theme === habitData.settings.theme) {
                    option.classList.add('active');
                }
            });
            
            // Set font
            document.body.classList.add(`font-${habitData.settings.font}`);
            
            // Update font selector
            fontOptions.forEach(option => {
                option.classList.remove('active');
                if (option.dataset.font === habitData.settings.font) {
                    option.classList.add('active');
                }
            });
            
            // Set toggles
            autoCompleteToggle.checked = habitData.settings.autoComplete;
            soundToggle.checked = habitData.settings.soundNotifications;
            confettiToggle.checked = habitData.settings.confettiEffects;
            
            // Set timer defaults
            defaultWorkTime.value = habitData.settings.defaultWorkTime;
            defaultBreakTime.value = habitData.settings.defaultBreakTime;
            
            // Update pomodoro settings
            pomodoroWork.value = habitData.settings.defaultWorkTime;
            pomodoroBreak.value = habitData.settings.defaultBreakTime;
        }

        // Add DOM references
        const newQuoteInput = document.getElementById('newQuote');
        const quoteAuthorInput = document.getElementById('quoteAuthor');
        const addQuoteBtn = document.getElementById('addQuoteBtn');
        const quotesList = document.getElementById('quotesList');
        
        // Setup quote management
        function setupQuoteManagement() {
            // Initialize custom quotes if not exists
            if (!habitData.customQuotes) {
                habitData.customQuotes = [];
            }
            
            // Add quote button click
            addQuoteBtn.addEventListener('click', () => {
                const quoteText = newQuoteInput.value.trim();
                const author = quoteAuthorInput.value.trim();
                
                if (quoteText) {
                    // Create quote object
                    const quote = author ? 
                        `${quoteText} - ${author}` : 
                        quoteText;
                    
                    // Add to custom quotes
                    habitData.customQuotes.push(quote);
                    
                    // Add to motivational quotes for display
                    motivationalQuotes.push(quote);
                    
                    // Save data
                    saveData();
                    
                    // Clear inputs
                    newQuoteInput.value = '';
                    quoteAuthorInput.value = '';
                    
                    // Refresh quotes list
                    renderQuotesList();
                    
                    // Show new quote
                    displayRandomQuote();
                } else {
                    alert('Please enter a quote.');
                }
            });
            
            // Render initial quotes list
            renderQuotesList();
        }
        
        // Render quotes list
        function renderQuotesList() {
            quotesList.innerHTML = '';
            
            if (habitData.customQuotes && habitData.customQuotes.length > 0) {
                habitData.customQuotes.forEach((quote, index) => {
                    const quoteItem = document.createElement('li');
                    quoteItem.style.padding = '10px';
                    quoteItem.style.margin = '5px 0';
                    quoteItem.style.background = 'rgba(255, 255, 255, 0.1)';
                    quoteItem.style.borderRadius = '8px';
                    quoteItem.style.display = 'flex';
                    quoteItem.style.justifyContent = 'space-between';
                    quoteItem.style.alignItems = 'center';
                    
                    const quoteText = document.createElement('span');
                    quoteText.textContent = quote;
                    quoteText.style.flex = '1';
                    quoteText.style.overflow = 'hidden';
                    quoteText.style.textOverflow = 'ellipsis';
                    quoteText.style.whiteSpace = 'nowrap';
                    
                    const deleteBtn = document.createElement('button');
                    deleteBtn.innerHTML = '<i class="fas fa-trash"></i>';
                    deleteBtn.className = 'btn btn-danger';
                    deleteBtn.style.marginLeft = '10px';
                    deleteBtn.style.padding = '5px 10px';
                    
                    deleteBtn.addEventListener('click', () => {
                        // Remove from custom quotes
                        habitData.customQuotes.splice(index, 1);
                        
                        // Remove from motivational quotes
                        const quoteIndex = motivationalQuotes.indexOf(quote);
                        if (quoteIndex !== -1) {
                            motivationalQuotes.splice(quoteIndex, 1);
                        }
                        
                        // Save data
                        saveData();
                        
                        // Refresh quotes list
                        renderQuotesList();
                    });
                    
                    quoteItem.appendChild(quoteText);
                    quoteItem.appendChild(deleteBtn);
                    
                    quotesList.appendChild(quoteItem);
                });
            } else {
                const emptyMessage = document.createElement('li');
                emptyMessage.textContent = 'No custom quotes yet. Add some above!';
                emptyMessage.style.fontStyle = 'italic';
                emptyMessage.style.color = '#999';
                emptyMessage.style.padding = '10px';
                quotesList.appendChild(emptyMessage);
            }
        }
        
        // Update display random quote to include custom quotes
        function displayRandomQuote() {
            // Combine default and custom quotes
            const allQuotes = [...motivationalQuotes];
            
            // Add custom quotes if they exist
            if (habitData.customQuotes && habitData.customQuotes.length > 0) {
                // Custom quotes are already part of motivationalQuotes now
            }
            
            const randomIndex = Math.floor(Math.random() * allQuotes.length);
            motivationQuoteElement.textContent = allQuotes[randomIndex];
        }
        
        // Fix font buttons by updating the loadSettings function
        function loadSettings() {
            // Set theme
            document.body.className = habitData.settings.theme !== 'default' ? 
                `theme-${habitData.settings.theme}` : '';
            
            // Apply dark mode if saved
            applyDarkModeIfSaved();
            
            // Update theme selector
            themeOptions.forEach(option => {
                option.classList.remove('active');
                if (option.dataset.theme === habitData.settings.theme) {
                    option.classList.add('active');
                }
            });
            
            // Set font
            document.body.classList.add(`font-${habitData.settings.font || 'sans'}`);
            
            // Update font selector
            fontOptions.forEach(option => {
                option.classList.remove('active');
                if (option.dataset.font === (habitData.settings.font || 'sans')) {
                    option.classList.add('active');
                }
            });
            
            // Set toggles
            if (autoCompleteToggle) autoCompleteToggle.checked = habitData.settings.autoComplete;
            if (soundToggle) soundToggle.checked = habitData.settings.soundNotifications;
            if (confettiToggle) confettiToggle.checked = habitData.settings.confettiEffects;
            
            // Set timer defaults
            if (defaultWorkTime) defaultWorkTime.value = habitData.settings.defaultWorkTime;
            if (defaultBreakTime) defaultBreakTime.value = habitData.settings.defaultBreakTime;
            
            // Update pomodoro settings
            if (pomodoroWork) pomodoroWork.value = habitData.settings.defaultWorkTime;
            if (pomodoroBreak) pomodoroBreak.value = habitData.settings.defaultBreakTime;
        }
        
        // Fix setupSettingsPanel function for font buttons
        function setupSettingsPanel() {
            // Open settings panel
            settingsBtn.addEventListener('click', () => {
                settingsPanel.classList.add('open');
            });
            
            // Close settings panel
            closeSettings.addEventListener('click', () => {
                settingsPanel.classList.remove('open');
            });
            
            // Theme options
            themeOptions.forEach(option => {
                option.addEventListener('click', () => {
                    // Remove previous theme
                    document.body.className = '';
                    
                    // Add new theme
                    const theme = option.dataset.theme;
                    if (theme !== 'default') {
                        document.body.classList.add(`theme-${theme}`);
                    }
                    
                    // Add font back
                    document.body.classList.add(`font-${habitData.settings.font || 'sans'}`);
                    
                    // Add dark mode back if active or if selecting dark theme
                    if (theme === 'dark') {
                        document.body.classList.add('dark-mode');
                        darkModeToggle.classList.add('active');
                        darkModeToggle.innerHTML = '<i class="fas fa-sun"></i> Light Mode';
                        habitData.settings.darkMode = true;
                    } else if (habitData.settings.darkMode && theme !== 'dark') {
                        // Remove dark mode if switching to another theme
                        habitData.settings.darkMode = false;
                        darkModeToggle.classList.remove('active');
                        darkModeToggle.innerHTML = '<i class="fas fa-moon"></i> Dark Mode';
                    }
                    
                    // Update active state
                    themeOptions.forEach(opt => opt.classList.remove('active'));
                    option.classList.add('active');
                    
                    // Save settings
                    habitData.settings.theme = theme;
                    saveData();
                });
            });
            
            // Font options
            fontOptions.forEach(option => {
                option.addEventListener('click', () => {
                    // Get the font type
                    const font = option.dataset.font;
                    
                    // Remove previous font classes
                    document.body.classList.remove('font-sans', 'font-serif', 'font-mono');
                    
                    // Add new font
                    document.body.classList.add(`font-${font}`);
                    
                    // Update active state
                    fontOptions.forEach(opt => opt.classList.remove('active'));
                    option.classList.add('active');
                    
                    // Save settings
                    habitData.settings.font = font;
                    saveData();
                });
            });
            
            // Toggle settings
            if (autoCompleteToggle) {
                autoCompleteToggle.addEventListener('change', () => {
                    habitData.settings.autoComplete = autoCompleteToggle.checked;
                    saveData();
                });
            }
            
            if (soundToggle) {
                soundToggle.addEventListener('change', () => {
                    habitData.settings.soundNotifications = soundToggle.checked;
                    saveData();
                });
            }
            
            if (confettiToggle) {
                confettiToggle.addEventListener('change', () => {
                    habitData.settings.confettiEffects = confettiToggle.checked;
                    saveData();
                });
            }
            
            // Timer settings
            if (defaultWorkTime) {
                defaultWorkTime.addEventListener('change', () => {
                    habitData.settings.defaultWorkTime = parseInt(defaultWorkTime.value);
                    saveData();
                });
            }
            
            if (defaultBreakTime) {
                defaultBreakTime.addEventListener('change', () => {
                    habitData.settings.defaultBreakTime = parseInt(defaultBreakTime.value);
                    saveData();
                });
            }
        }
        
        // Update initialization to include quote management
        function initApp() {
            loadData();
            renderGoals();
            updateLeaderboard();
            displayRandomQuote();
            checkStreak();
            renderBadges();
            initChart();
            setupAutoComplete();
            initializeHistory();
            setupGraphCustomization();
            setupRealTimeUpdates();
            setupQuoteManagement();
            setupQuoteNavigation();
            setupCollapsibleSections();
            setupDataOptions();
            
            if (!habitData.user.lastActive) {
                showWelcomeModal();
            }
        }

        // Add DOM references
        const prevQuoteBtn = document.getElementById('prevQuoteBtn');
        const nextQuoteBtn = document.getElementById('nextQuoteBtn');
        const addQuoteModalBtn = document.getElementById('addQuoteModalBtn');
        const manageQuotesBtn = document.getElementById('manageQuotesBtn');
        const addQuoteModal = document.getElementById('addQuoteModal');
        const closeAddQuoteModal = document.getElementById('closeAddQuoteModal');
        const newQuoteText = document.getElementById('newQuoteText');
        const newQuoteAuthor = document.getElementById('newQuoteAuthor');
        const saveQuoteBtn = document.getElementById('saveQuoteBtn');
        const manageQuotesModal = document.getElementById('manageQuotesModal');
        const closeManageQuotesModal = document.getElementById('closeManageQuotesModal');
        const manageQuotesList = document.getElementById('manageQuotesList');
        
        // Current quote index
        let currentQuoteIndex = 0;
        let allQuotes = [];
        
        // Setup quote navigation
        function setupQuoteNavigation() {
            // Combine default and custom quotes
            updateQuotesList();
            
            // Display initial quote
            displayQuoteByIndex(currentQuoteIndex);
            
            // Previous quote button
            prevQuoteBtn.addEventListener('click', () => {
                currentQuoteIndex = (currentQuoteIndex - 1 + allQuotes.length) % allQuotes.length;
                displayQuoteByIndex(currentQuoteIndex);
            });
            
            // Next quote button
            nextQuoteBtn.addEventListener('click', () => {
                currentQuoteIndex = (currentQuoteIndex + 1) % allQuotes.length;
                displayQuoteByIndex(currentQuoteIndex);
            });
            
            // Add quote button
            addQuoteModalBtn.addEventListener('click', () => {
                newQuoteText.value = '';
                newQuoteAuthor.value = '';
                addQuoteModal.style.display = 'flex';
            });
            
            // Close add quote modal
            closeAddQuoteModal.addEventListener('click', () => {
                addQuoteModal.style.display = 'none';
            });
            
            // Save quote button
            saveQuoteBtn.addEventListener('click', () => {
                addNewQuote();
            });
            
            // Manage quotes button
            manageQuotesBtn.addEventListener('click', () => {
                console.log('Manage quotes button clicked');
                renderManageQuotesList();
                manageQuotesModal.style.display = 'flex';
            });
            
            // Close manage quotes modal
            closeManageQuotesModal.addEventListener('click', () => {
                manageQuotesModal.style.display = 'none';
            });
        }
        
        // Update the list of all quotes
        function updateQuotesList() {
            allQuotes = [...motivationalQuotes];
            
            // Add custom quotes if they exist
            if (habitData.customQuotes && habitData.customQuotes.length > 0) {
                habitData.customQuotes.forEach(quote => {
                    if (!allQuotes.includes(quote)) {
                        allQuotes.push(quote);
                    }
                });
            }
        }
        
        // Display quote by index
        function displayQuoteByIndex(index) {
            if (allQuotes.length > 0) {
                motivationQuoteElement.textContent = allQuotes[index];
            }
        }
        
        // Add new quote
        function addNewQuote() {
            const quoteText = newQuoteText.value.trim();
            const author = newQuoteAuthor.value.trim();
            
            if (quoteText) {
                // Create quote object
                const quote = author ? 
                    `${quoteText} - ${author}` : 
                    quoteText;
                
                // Add to custom quotes
                if (!habitData.customQuotes) {
                    habitData.customQuotes = [];
                }
                habitData.customQuotes.push(quote);
                
                // Update all quotes list
                updateQuotesList();
                
                // Save data
                saveData();
                
                // Clear inputs and close modal
                newQuoteText.value = '';
                newQuoteAuthor.value = '';
                addQuoteModal.style.display = 'none';
                
                // Show the new quote
                currentQuoteIndex = allQuotes.length - 1;
                displayQuoteByIndex(currentQuoteIndex);
                
                // Show confirmation
                alert('Quote added successfully!');
            } else {
                alert('Please enter a quote.');
            }
        }
        
        // Render quotes list for management
        function renderManageQuotesList() {
            manageQuotesList.innerHTML = '';
            
            // Default quotes section
            const defaultQuotesHeader = document.createElement('li');
            defaultQuotesHeader.textContent = 'Default Quotes';
            defaultQuotesHeader.style.fontWeight = 'bold';
            defaultQuotesHeader.style.padding = '10px';
            defaultQuotesHeader.style.backgroundColor = 'rgba(67, 97, 238, 0.1)';
            defaultQuotesHeader.style.borderRadius = '5px';
            defaultQuotesHeader.style.marginBottom = '5px';
            manageQuotesList.appendChild(defaultQuotesHeader);
            
            motivationalQuotes.forEach((quote, index) => {
                // Skip quotes that are in custom quotes (to avoid duplicates)
                if (habitData.customQuotes && habitData.customQuotes.includes(quote)) {
                    return;
                }
                
                const quoteItem = createQuoteListItem(quote, index, false);
                manageQuotesList.appendChild(quoteItem);
            });
            
            // Custom quotes section
            if (habitData.customQuotes && habitData.customQuotes.length > 0) {
                const customQuotesHeader = document.createElement('li');
                customQuotesHeader.textContent = 'Your Custom Quotes';
                customQuotesHeader.style.fontWeight = 'bold';
                customQuotesHeader.style.padding = '10px';
                customQuotesHeader.style.backgroundColor = 'rgba(247, 37, 133, 0.1)';
                customQuotesHeader.style.borderRadius = '5px';
                customQuotesHeader.style.marginTop = '15px';
                customQuotesHeader.style.marginBottom = '5px';
                manageQuotesList.appendChild(customQuotesHeader);
                
                habitData.customQuotes.forEach((quote, index) => {
                    const quoteItem = createQuoteListItem(quote, index, true);
                    manageQuotesList.appendChild(quoteItem);
                });
            } else {
                const noCustomQuotes = document.createElement('li');
                noCustomQuotes.textContent = 'No custom quotes yet.';
                noCustomQuotes.style.fontStyle = 'italic';
                noCustomQuotes.style.color = '#999';
                noCustomQuotes.style.padding = '10px';
                noCustomQuotes.style.marginTop = '15px';
                manageQuotesList.appendChild(noCustomQuotes);
            }
        }
        
        // Create quote list item for management
        function createQuoteListItem(quote, index, isCustom) {
            const quoteItem = document.createElement('li');
            quoteItem.style.padding = '10px';
            quoteItem.style.margin = '5px 0';
            quoteItem.style.background = 'rgba(255, 255, 255, 0.1)';
            quoteItem.style.borderRadius = '8px';
            quoteItem.style.display = 'flex';
            quoteItem.style.justifyContent = 'space-between';
            quoteItem.style.alignItems = 'center';
            
            const quoteText = document.createElement('span');
            quoteText.textContent = quote;
            quoteText.style.flex = '1';
            quoteText.style.overflow = 'hidden';
            quoteText.style.textOverflow = 'ellipsis';
            quoteText.style.whiteSpace = 'nowrap';
            
            quoteItem.appendChild(quoteText);
            
            // Only add delete button for custom quotes
            if (isCustom) {
                const deleteBtn = document.createElement('button');
                deleteBtn.innerHTML = '<i class="fas fa-trash"></i>';
                deleteBtn.className = 'btn btn-danger';
                deleteBtn.style.marginLeft = '10px';
                deleteBtn.style.padding = '5px 10px';
                
                deleteBtn.addEventListener('click', () => {
                    // Remove from custom quotes
                    habitData.customQuotes.splice(index, 1);
                    
                    // Update quotes list
                    updateQuotesList();
                    
                    // Save data
                    saveData();
                    
                    // Refresh quotes list
                    renderManageQuotesList();
                    
                    // Update current quote if needed
                    if (currentQuoteIndex >= allQuotes.length) {
                        currentQuoteIndex = 0;
                    }
                    displayQuoteByIndex(currentQuoteIndex);
                });
                
                quoteItem.appendChild(deleteBtn);
            }
            
            // Add "Show Now" button
            const showNowBtn = document.createElement('button');
            showNowBtn.innerHTML = '<i class="fas fa-eye"></i>';
            showNowBtn.className = 'btn btn-primary';
            showNowBtn.style.marginLeft = '10px';
            showNowBtn.style.padding = '5px 10px';
            showNowBtn.title = 'Show this quote now';
            
            showNowBtn.addEventListener('click', () => {
                // Find the quote in the combined list
                const quoteIndex = allQuotes.indexOf(quote);
                if (quoteIndex !== -1) {
                    currentQuoteIndex = quoteIndex;
                    displayQuoteByIndex(currentQuoteIndex);
                }
                
                // Close the modal
                manageQuotesModal.style.display = 'none';
            });
            
            quoteItem.appendChild(showNowBtn);
            
            return quoteItem;
        }
        
        // Update the display random quote function
        function displayRandomQuote() {
            updateQuotesList();
            
            if (allQuotes.length > 0) {
                const randomIndex = Math.floor(Math.random() * allQuotes.length);
                currentQuoteIndex = randomIndex;
                motivationQuoteElement.textContent = allQuotes[randomIndex];
            }
        }

        // Setup collapsible sections
        function setupCollapsibleSections() {
            const customizationHeader = document.getElementById('customizationHeader');
            const customizationContent = document.getElementById('customizationContent');
            const customizationChevron = document.getElementById('customizationChevron');
            
            // Initialize collapsed state
            let isCustomizationExpanded = false;
            
            // Add click event
            customizationHeader.addEventListener('click', () => {
                isCustomizationExpanded = !isCustomizationExpanded;
                
                // Toggle content display
                customizationContent.style.display = isCustomizationExpanded ? 'grid' : 'none';
                
                // Rotate chevron icon
                customizationChevron.style.transform = isCustomizationExpanded ? 'rotate(180deg)' : 'rotate(0deg)';
                customizationChevron.style.transition = 'transform 0.3s';
                
                // Save preference
                if (habitData.settings) {
                    habitData.settings.isCustomizationExpanded = isCustomizationExpanded;
                    saveData();
                }
            });
            
            // Check saved preference
            if (habitData.settings && habitData.settings.isCustomizationExpanded) {
                isCustomizationExpanded = true;
                customizationContent.style.display = 'grid';
                customizationChevron.style.transform = 'rotate(180deg)';
            }
        }

        // Removed duplicate backup/restore buttons code - using header buttons instead

        // Add these functions to the main script section
        // Backup data to a file
        function backupData() {
            try {
                const dataStr = JSON.stringify(habitData, null, 2);
                const dataBlob = new Blob([dataStr], { type: 'application/json' });
                const url = URL.createObjectURL(dataBlob);
                
                const downloadLink = document.createElement('a');
                downloadLink.href = url;
                downloadLink.download = `habit_tracker_backup_${new Date().toISOString().slice(0, 10)}.json`;
                document.body.appendChild(downloadLink);
                downloadLink.click();
                document.body.removeChild(downloadLink);
                
                alert('Data backed up successfully! Keep this file safe to restore your progress later.');
            } catch (error) {
                console.error('Error creating backup:', error);
                alert('Error creating backup. Please try again.');
            }
        }

        // Restore data from a file
        function restoreData() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            
            input.addEventListener('change', function(e) {
                const file = e.target.files[0];
                if (!file) return;
                
                const reader = new FileReader();
                reader.onload = function(e) {
                    try {
                        const data = JSON.parse(e.target.result);
                        
                        // Basic validation
                        if (data && data.user && data.goals && data.competitors) {
                            // Ask for confirmation
                            if (confirm('Are you sure you want to replace your current data with the backup? This cannot be undone.')) {
                                habitData = data;
                                saveData();
                                alert('Data restored successfully!');
                                window.location.reload();
                            }
                        } else {
                            alert('Invalid backup file. Please select a valid backup.');
                        }
                    } catch (error) {
                        console.error('Error parsing backup file:', error);
                        alert('Error restoring from backup. The file might be corrupted.');
                    }
                };
                reader.readAsText(file);
            });
            
            input.click();
        }

        // Add auto-save functionality
        setInterval(function() {
            saveData();
        }, 30000); // Auto-save every 30 seconds

        // Add a function to change competitor color
        function changeCompetitorColor(index, color) {
            habitData.competitors[index].color = color;
            saveData();
            
            // Recreate chart with new colors
            if (chart) {
                chart.destroy();
            }
            initChart();
        }

        // Modify initChart to use custom competitor colors
        function initChart() {
            const ctx = progressChart.getContext('2d');
            
            // Generate some sample data if history is empty
            if (habitData.user.history.length === 0) {
                generateSampleHistory();
            }
            
            // Prepare data for the chart
            const labels = habitData.user.history.map((_, index) => `Day ${index + 1}`);
            const userData = habitData.user.history;
            
            const competitorsData = habitData.competitors.map(competitor => {
                // Use saved color or generate a random one if not set
                const color = competitor.color || getRandomColor();
                
                // Save the color if not already set
                if (!competitor.color) {
                    competitor.color = color;
                    saveData();
                }
                
                return {
                    label: competitor.name,
                    data: competitor.history,
                    borderColor: color,
                    backgroundColor: 'rgba(0, 0, 0, 0)',
                    borderWidth: 2,
                    tension: 0.3
                };
            });
            
            // Create the chart
            chart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [
                        {
                            label: 'You',
                            data: userData,
                            borderColor: chartColors.userLine,
                            backgroundColor: 'rgba(0, 0, 0, 0)',
                            borderWidth: 3,
                            tension: 0.3
                        },
                        ...competitorsData
                    ]
                },
                options: {
                    responsive: true,
                    scales: {
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: 'Points'
                            },
                            grid: {
                                display: chartColors.showGridLines
                            }
                        },
                        x: {
                            title: {
                                display: true,
                                text: 'Days'
                            },
                            grid: {
                                display: chartColors.showGridLines
                            }
                        }
                    },
                    plugins: {
                        legend: {
                            position: 'bottom'
                        }
                    }
                }
            });
        }

        // Close dropdown when clicking elsewhere
        document.addEventListener('click', (e) => {
            if (!dataOptionsBtn.contains(e.target) && !dropdownContent.contains(e.target)) {
                dropdownContent.style.display = 'none';
            }
        });

        // Quick timer controls
        const quickStartTimerBtn = document.getElementById('quickStartTimerBtn');
        const quickPauseTimerBtn = document.getElementById('quickPauseTimerBtn');
        const quickResetTimerBtn = document.getElementById('quickResetTimerBtn');

        // Connect quick timer buttons to the timer functionality
        if (quickStartTimerBtn) {
            quickStartTimerBtn.addEventListener('click', () => {
                // Open timer modal if not already open
                timerModal.style.display = 'flex';
                
                // Start the timer
                startTimer();
            });
        }

        if (quickPauseTimerBtn) {
            quickPauseTimerBtn.addEventListener('click', () => {
                // Open timer modal if not already open
                timerModal.style.display = 'flex';
                
                // Pause the timer
                pauseTimer();
            });
        }

        if (quickResetTimerBtn) {
            quickResetTimerBtn.addEventListener('click', () => {
                // Open timer modal if not already open
                timerModal.style.display = 'flex';
                
                // Reset the timer
                resetTimer();
            });
        }

        // Get skip buttons
        const skipWorkBtn = document.getElementById('skipWorkBtn');
        const skipBreakBtn = document.getElementById('skipBreakBtn');

        // Skip to break
        skipWorkBtn.addEventListener('click', () => {
            if (timerMode === 'work') {
                // Clear current timer
                clearInterval(timer);
                
                // Handle cycle completion
                pomodoroCurrentCycle++;
                const totalCycles = parseInt(pomodoroCycles.value);
                
                // Update progress
                pomodoroProgress.textContent = `${pomodoroCurrentCycle}/${totalCycles}`;
                pomodoroProgressBar.style.width = `${(pomodoroCurrentCycle / totalCycles) * 100}%`;
                
                // Auto-complete task if work cycle skipped
                if (currentGoalIdForTimer && currentSubtaskIdForTimer) {
                    const goal = habitData.goals.find(g => g.id === currentGoalIdForTimer);
                    if (goal) {
                        const subtask = goal.subtasks.find(s => s.id === currentSubtaskIdForTimer);
                        if (subtask && !subtask.completed) {
                            toggleSubtask(currentGoalIdForTimer, currentSubtaskIdForTimer);
                        }
                    }
                }
                
                // Check if we need a long break
                if (pomodoroCurrentCycle % totalCycles === 0) {
                    timerMode = 'longBreak';
                    totalSeconds = parseInt(pomodoroLongBreak.value) * 60;
                    alert('Skipped to long break!');
                } else {
                    timerMode = 'break';
                    totalSeconds = parseInt(pomodoroBreak.value) * 60;
                    alert('Skipped to short break!');
                }
                
                // Reset timer buttons
                timerRunning = false;
                startTimerBtn.disabled = false;
                pauseTimerBtn.disabled = true;
                
                // Update display
                const minutes = Math.floor(totalSeconds / 60);
                const seconds = totalSeconds % 60;
                timerMinutes.textContent = minutes < 10 ? '0' + minutes : minutes;
                timerSeconds.textContent = seconds < 10 ? '0' + seconds : seconds;
            }
        });

        // Skip to work
        skipBreakBtn.addEventListener('click', () => {
            if (timerMode === 'break' || timerMode === 'longBreak') {
                // Clear current timer
                clearInterval(timer);
                
                // Break time finished, back to work
                timerMode = 'work';
                totalSeconds = parseInt(pomodoroWork.value) * 60;
                alert('Skipped to work!');
                
                // Reset timer buttons
                timerRunning = false;
                startTimerBtn.disabled = false;
                pauseTimerBtn.disabled = true;
                
                // Update display
                const minutes = Math.floor(totalSeconds / 60);
                const seconds = totalSeconds % 60;
                timerMinutes.textContent = minutes < 10 ? '0' + minutes : minutes;
                timerSeconds.textContent = seconds < 10 ? '0' + seconds : seconds;
            }
        });

        document.getElementById('customizeCompetitors').addEventListener('click', function() {
            document.getElementById('competitorModal').style.display = 'block';
        });

        function addBonusTask(task, points) {
            // ... existing code ...
            
            calculateUserScore();
            saveData();
            updateUI();
            
            // Update leaderboard in real-time when a bonus task is added
            updateLeaderboard();
            
            // Show toast notification
            showToast(`Added bonus task: ${task} (+${points} points)`);
        }

        // Set up periodic leaderboard updates for real-time feel
        let leaderboardUpdateInterval;

        function startLeaderboardUpdates() {
            // Update leaderboard every 30-60 seconds randomly to create a dynamic feel
            leaderboardUpdateInterval = setInterval(() => {
                // Small random adjustments to competitor scores
                habitData.competitors.forEach(competitor => {
                    // 50% chance of score change
                    if (Math.random() > 0.5) {
                        // Determine if score goes up or down
                        const direction = Math.random() > 0.5 ? 1 : -1;
                        // Small random change (1-3 points)
                        const change = Math.floor(Math.random() * 3) + 1;
                        competitor.score += direction * change;
                        
                        // Ensure score doesn't go negative
                        if (competitor.score < 0) competitor.score = 0;
                    }
                });
                
                // Update the leaderboard with the new scores
                updateLeaderboard();
            }, Math.floor(Math.random() * 30000) + 30000); // Random interval between 30-60 seconds
        }

        function stopLeaderboardUpdates() {
            clearInterval(leaderboardUpdateInterval);
        }

        // Start the updates when the page loads
        window.addEventListener('DOMContentLoaded', () => {
            // ... existing code ...
            
            // Start periodic leaderboard updates
            startLeaderboardUpdates();
        });

        // Stop updates when the page is hidden to save resources
        document.addEventListener('visibilitychange', () => {
            if (document.hidden) {
                stopLeaderboardUpdates();
            } else {
                startLeaderboardUpdates();
            }
        });

        // ... existing code ...
        // Add to the DOMContentLoaded event handler
        window.addEventListener('DOMContentLoaded', () => {
            // ... existing code ...
            
            // Set up analysis functionality
            setupAnalysisModal();
        });

        // Setup Analysis Modal
        function setupAnalysisModal() {
            const analysisBtn = document.getElementById('analysisBtn');
            const analysisModal = document.getElementById('analysisModal');
            const closeAnalysisModal = document.getElementById('closeAnalysisModal');
            const analysisTabs = document.querySelectorAll('.analysis-tab');
            
            // Add refresh button to modal header
            const modalHeader = analysisModal.querySelector('.modal-header');
            if (modalHeader && !document.getElementById('refreshAnalysisBtn')) {
                const refreshBtn = document.createElement('button');
                refreshBtn.id = 'refreshAnalysisBtn';
                refreshBtn.className = 'btn-icon';
                refreshBtn.innerHTML = '<i class="fas fa-sync-alt"></i>';
                refreshBtn.title = 'Refresh Analysis Data';
                refreshBtn.style.marginRight = 'auto';
                refreshBtn.style.marginLeft = '10px';
                refreshBtn.style.background = 'transparent';
                refreshBtn.style.border = 'none';
                refreshBtn.style.color = 'var(--primary)';
                refreshBtn.style.fontSize = '1.2rem';
                refreshBtn.style.cursor = 'pointer';
                
                refreshBtn.addEventListener('click', () => {
                    console.log('Manually refreshing analysis data');
                    loadAnalysisData();
                    showNotification('Analysis data refreshed', 'info');
                });
                
                // Insert after the title
                const modalTitle = modalHeader.querySelector('h2');
                if (modalTitle) {
                    modalTitle.after(refreshBtn);
                } else {
                    modalHeader.prepend(refreshBtn);
                }
            }
            
            // Open modal when clicking the Analysis button
            analysisBtn.addEventListener('click', () => {
                analysisModal.style.display = 'flex';
                
                // Apply current theme to analysis modal
                applyThemeToAnalysisModal();
                
                // Load the analysis data when opening the modal
                loadAnalysisData();
            });
            
            // Close modal when clicking the close button
            closeAnalysisModal.addEventListener('click', () => {
                analysisModal.style.display = 'none';
            });
            
            // Close modal when clicking outside of it
            window.addEventListener('click', (e) => {
                if (e.target === analysisModal) {
                    analysisModal.style.display = 'none';
                }
            });
            
            // Tab switching
            analysisTabs.forEach(tab => {
                tab.addEventListener('click', () => {
                    // Remove active class from all tabs and content
                    analysisTabs.forEach(t => t.classList.remove('active'));
                    document.querySelectorAll('.analysis-tab-content').forEach(content => {
                        content.classList.remove('active');
                    });
                    
                    // Add active class to clicked tab and corresponding content
                    tab.classList.add('active');
                    const tabName = tab.getAttribute('data-tab');
                    document.getElementById(`${tabName}-tab`).classList.add('active');
                });
            });
        }

        // Apply current theme to analysis modal
        function applyThemeToAnalysisModal() {
            const isDarkMode = document.body.classList.contains('dark-mode');
            const modalContent = document.querySelector('#analysisModal .modal-content');
            const charts = document.querySelectorAll('#analysisModal canvas');
            
            // Update chart colors based on theme
            charts.forEach(chart => {
                if (chart.chart) {
                    // If Chart.js instance exists, update its colors
                    const chartInstance = chart.chart;
                    
                    if (isDarkMode) {
                        // Dark mode chart colors
                        chartInstance.options.scales.x.grid.color = 'rgba(255, 255, 255, 0.1)';
                        chartInstance.options.scales.y.grid.color = 'rgba(255, 255, 255, 0.1)';
                        chartInstance.options.scales.x.ticks.color = 'rgba(255, 255, 255, 0.7)';
                        chartInstance.options.scales.y.ticks.color = 'rgba(255, 255, 255, 0.7)';
                    } else {
                        // Light mode chart colors
                        chartInstance.options.scales.x.grid.color = 'rgba(0, 0, 0, 0.1)';
                        chartInstance.options.scales.y.grid.color = 'rgba(0, 0, 0, 0.1)';
                        chartInstance.options.scales.x.ticks.color = 'rgba(0, 0, 0, 0.7)';
                        chartInstance.options.scales.y.ticks.color = 'rgba(0, 0, 0, 0.7)';
                    }
                    
                    chartInstance.update();
                }
            });
        }

        // Function to load analysis data
        function loadAnalysisData() {
            console.log('Loading real analysis data...');
            
            // Ensure we're working with the most current data
            const currentData = JSON.parse(localStorage.getItem('habitData'));
            if (currentData) {
                // Update our in-memory data with the latest from storage
                habitData = currentData;
                console.log('Updated habitData from localStorage for analysis:', habitData.user.points, 'points');
            }
            
            // Use real data instead of sample data
            generateRealAnalysisData();
            
            // Make sure the performance tab is highlighted
            document.querySelector('.analysis-tab[data-tab="performance"]').classList.add('active');
            document.getElementById('performance-tab').classList.add('active');
            
            // Add a more descriptive header
            const performanceHeader = document.querySelector('#performance-tab h3');
            if (performanceHeader) {
                performanceHeader.innerHTML = '<i class="fas fa-chart-line"></i> Your Performance Analysis';
                performanceHeader.style.color = 'var(--primary)';
                performanceHeader.style.fontSize = '1.6rem';
                performanceHeader.style.marginBottom = '20px';
                performanceHeader.style.borderBottom = '2px solid var(--primary-light)';
                performanceHeader.style.paddingBottom = '10px';
            }
            
            // Set standard height for all chart containers
            const chartContainers = document.querySelectorAll('.analysis-chart');
            chartContainers.forEach(container => {
                container.style.height = '400px'; // Increased from 300px to 400px for better visibility
                container.style.marginBottom = '30px'; // Increased margin for better spacing
            });
        }

        // Generate real analysis data from user data
        function generateRealAnalysisData() {
            // Clear existing metrics container
            const metricsContainer = document.querySelector('.analysis-metrics-container');
            metricsContainer.innerHTML = '';
            
            // Calculate current statistics for display
            const totalGoals = habitData.goals.length;
            const completedGoals = habitData.goals.filter(goal => 
                goal.subtasks.length > 0 && 
                goal.subtasks.every(subtask => subtask.completed)
            ).length;
            
            // Count total and completed subtasks
            let totalSubtasks = 0;
            let completedSubtasks = 0;
            habitData.goals.forEach(goal => {
                totalSubtasks += goal.subtasks.length;
                completedSubtasks += goal.subtasks.filter(subtask => subtask.completed).length;
            });
            
            // Calculate total points earned
            const totalPoints = habitData.user.points || 0;
            
            // Calculate completion percentage
            const completionPercentage = totalSubtasks > 0 
                ? Math.round((completedSubtasks / totalSubtasks) * 100) 
                : 0;
            
            // Add current statistics to metrics container
            metricsContainer.innerHTML = `
                <div class="metric-card">
                    <h4>Current Progress</h4>
                    <div class="metric-value">${completedGoals}/${totalGoals} Goals</div>
                    <div class="metric-value">${completedSubtasks}/${totalSubtasks} Subtasks</div>
                    <div class="metric-value">${completionPercentage}% Completion Rate</div>
                    <div class="metric-value">${totalPoints} Total Points</div>
                </div>
            `;
            
            // 1. Task Completion Chart - Use real completion rates if available
            const taskCompletionCtx = document.getElementById('taskCompletionChart').getContext('2d');
            
            // Calculate completion rates for the last 7 days
            const days = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
            const completionData = Array(7).fill(0);
            const pointsData = Array(7).fill(0);
            const labels = [];
            
            // Get the last 7 days
            for (let i = 6; i >= 0; i--) {
                const date = new Date();
                date.setDate(date.getDate() - i);
                const dayIndex = date.getDay(); // 0 = Sunday, 6 = Saturday
                labels.unshift(days[dayIndex]);
                
                // Check if we have data for this day
                const dateStr = date.toLocaleDateString();
                if (habitData.user.dailyHistory && habitData.user.dailyHistory[dateStr]) {
                    const dayData = habitData.user.dailyHistory[dateStr];
                    const tasksCompleted = dayData.tasksCompleted || 0;
                    const pointsEarned = dayData.pointsEarned || 0;
                    
                    // Record actual values instead of percentages
                    completionData[6-i] = tasksCompleted;
                    pointsData[6-i] = pointsEarned;
                }
            }
            
            // Create the chart
            const taskCompletionChart = new Chart(taskCompletionCtx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [
                        {
                            label: 'Tasks Completed',
                        data: completionData,
                        backgroundColor: 'rgba(76, 201, 240, 0.2)',
                        borderColor: 'rgba(76, 201, 240, 1)',
                        borderWidth: 2,
                        tension: 0.3,
                            fill: true,
                            yAxisID: 'y'
                        },
                        {
                            label: 'Points Earned',
                            data: pointsData,
                            backgroundColor: 'rgba(247, 37, 133, 0.2)',
                            borderColor: 'rgba(247, 37, 133, 1)',
                            borderWidth: 2,
                            tension: 0.3,
                            fill: true,
                            yAxisID: 'y1'
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    layout: {
                        padding: 20
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: 'Tasks Completed',
                                color: document.body.classList.contains('dark-mode') ? '#eee' : '#333'
                            },
                            ticks: {
                                color: document.body.classList.contains('dark-mode') ? '#eee' : '#333'
                            },
                            grid: {
                                color: document.body.classList.contains('dark-mode') ? 'rgba(255, 255, 255, 0.1)' : 'rgba(0, 0, 0, 0.1)'
                            }
                        },
                        y1: {
                            beginAtZero: true,
                            position: 'right',
                            title: {
                                display: true,
                                text: 'Points Earned',
                                color: document.body.classList.contains('dark-mode') ? '#eee' : '#333'
                            },
                            ticks: {
                                color: document.body.classList.contains('dark-mode') ? '#eee' : '#333'
                            },
                            grid: {
                                color: 'transparent'
                            }
                        },
                        x: {
                            ticks: {
                                color: document.body.classList.contains('dark-mode') ? '#eee' : '#333'
                            },
                            grid: {
                                color: document.body.classList.contains('dark-mode') ? 'rgba(255, 255, 255, 0.1)' : 'rgba(0, 0, 0, 0.1)'
                            }
                        }
                    },
                    plugins: {
                        legend: {
                            labels: {
                                color: document.body.classList.contains('dark-mode') ? '#eee' : '#333'
                            }
                        },
                        tooltip: {
                            mode: 'index',
                            intersect: false
                        }
                    }
                }
            });
            
            // 2. Score Progression Chart - Use real score history
            const scoreProgressionCtx = document.getElementById('scoreProgressionChart').getContext('2d');
            
            // Create fixed week labels in the correct order
            const weekLabels = ['Week 1', 'Week 2', 'Week 3', 'Week 4'];
            // Initialize weekly scores array with zeros
            const weeklyScores = [0, 0, 0, 0];
            
            // Calculate weekly scores from history
            if (habitData.user.history && habitData.user.history.length > 0) {
                const history = [...habitData.user.history]; // Clone to avoid modifying original
                
                // Define each week's data range
                // We want Week 1 to be oldest data and Week 4 to be newest
                const weekRanges = [
                    { start: 0, end: 7 },           // Week 1: oldest week
                    { start: 7, end: 14 },          // Week 2
                    { start: 14, end: 21 },         // Week 3
                    { start: 21, end: 28 }          // Week 4: most recent week
                ];
                
                // Pad history if needed to have at least 28 days of data
                while (history.length < 28) {
                    history.unshift(0);
                }
                
                // Calculate average for each week
                for (let i = 0; i < 4; i++) {
                    const { start, end } = weekRanges[i];
                    const weekData = history.slice(
                        Math.max(0, history.length - end), 
                        Math.max(0, history.length - start)
                    );
                    
                    if (weekData.length > 0) {
                        const avg = Math.round(weekData.reduce((sum, val) => sum + val, 0) / weekData.length);
                        weeklyScores[i] = avg;
                    }
                }
            } else {
                // No history data, just use current score for Week 4
                weeklyScores[3] = habitData.user.score;
            }
            
            // Create the chart with the properly ordered data
            const scoreProgressionChart = new Chart(scoreProgressionCtx, {
                type: 'bar',
                data: {
                    labels: weekLabels,
                    datasets: [{
                        label: 'Weekly Score',
                        data: weeklyScores,
                        backgroundColor: 'rgba(247, 37, 133, 0.7)',
                        borderColor: 'rgba(247, 37, 133, 1)',
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    layout: {
                        padding: {
                            left: 10,
                            right: 10,
                            top: 10,
                            bottom: 10
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: 'Average Score'
                            }
                        },
                        x: {
                            title: {
                                display: true,
                                text: 'Time Period'
                            }
                        }
                    },
                    plugins: {
                        legend: {
                            display: false
                        },
                        tooltip: {
                            callbacks: {
                                title: function(tooltipItems) {
                                    return tooltipItems[0].label;
                                },
                                label: function(context) {
                                    return `Average Score: ${context.raw}`;
                                }
                            }
                        }
                    }
                }
            });
            
            // 3. Task Distribution Chart - Calculate based on actual subtasks
            const taskDistributionCtx = document.getElementById('taskDistributionChart').getContext('2d');
            
            // Calculate current category distribution from goals
            const taskTypes = {};
            
            // First collect all categories
            habitData.goals.forEach(goal => {
                const category = goal.category || 'Uncategorized';
                if (!taskTypes[category]) {
                    taskTypes[category] = {
                        total: 0,
                        completed: 0
                    };
                }
                taskTypes[category].total++;
                
                // Check if this goal has all subtasks completed
                if (goal.subtasks.length > 0 && goal.subtasks.every(st => st.completed)) {
                    taskTypes[category].completed++;
                }
            });
            
            // Prepare data for chart
            const categoryLabels = Object.keys(taskTypes);
            const categoryTotals = categoryLabels.map(cat => taskTypes[cat].total);
            const categoryCompletions = categoryLabels.map(cat => taskTypes[cat].completed);
            
            // Create color palette
            const categoryColors = [
                'rgba(76, 201, 240, 0.8)',
                'rgba(72, 149, 239, 0.8)',
                'rgba(67, 97, 238, 0.8)',
                'rgba(47, 73, 94, 0.8)',
                'rgba(47, 72, 88, 0.8)',
                'rgba(82, 183, 136, 0.8)',
                'rgba(150, 111, 214, 0.8)',
                'rgba(233, 116, 81, 0.8)'
            ];
            
            // Create the category distribution chart
            const taskDistributionChart = new Chart(taskDistributionCtx, {
                type: 'bar',
                data: {
                    labels: categoryLabels,
                    datasets: [
                        {
                            label: 'Total Tasks',
                            data: categoryTotals,
                            backgroundColor: categoryLabels.map((_, i) => 
                                categoryColors[i % categoryColors.length]
                            ),
                        borderWidth: 1
                        },
                        {
                            label: 'Completed Tasks',
                            data: categoryCompletions,
                            backgroundColor: categoryLabels.map((_, i) => 
                                categoryColors[i % categoryColors.length].replace('0.8', '0.4')
                            ),
                            borderWidth: 1
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: 'Number of Tasks',
                                color: document.body.classList.contains('dark-mode') ? '#eee' : '#333'
                            },
                            ticks: {
                                color: document.body.classList.contains('dark-mode') ? '#eee' : '#333'
                            },
                            grid: {
                                color: document.body.classList.contains('dark-mode') ? 'rgba(255, 255, 255, 0.1)' : 'rgba(0, 0, 0, 0.1)'
                            }
                        },
                        x: {
                            ticks: {
                                color: document.body.classList.contains('dark-mode') ? '#eee' : '#333'
                            },
                            grid: {
                                color: document.body.classList.contains('dark-mode') ? 'rgba(255, 255, 255, 0.1)' : 'rgba(0, 0, 0, 0.1)'
                            }
                        }
                    },
                    plugins: {
                        legend: {
                            position: 'top',
                            labels: {
                                color: document.body.classList.contains('dark-mode') ? '#eee' : '#333'
                            }
                        },
                        title: {
                            display: true,
                            text: 'Task Distribution by Category',
                            color: document.body.classList.contains('dark-mode') ? '#eee' : '#333'
                        }
                    }
                }
            });
            
            // 4. Add real performance metrics
            const metrics = [];
            
            // Current streak
            metrics.push({
                label: 'Current Streak',
                value: `${habitData.user.streak} days`
            });
            
            // Weekly Score Average
            const recentHistory = habitData.user.history.slice(-7);
            const weeklyScoreAvg = recentHistory.length > 0
                ? Math.round(recentHistory.reduce((sum, val) => sum + val, 0) / recentHistory.length)
                : habitData.user.score;
            
            metrics.push({
                label: 'Weekly Score Avg',
                value: weeklyScoreAvg.toString()
            });
            
            // Total Tasks Completed
            let totalCompleted = 0;
            habitData.goals.forEach(goal => {
                goal.subtasks.forEach(subtask => {
                    if (subtask.completed) {
                        totalCompleted++;
                    }
                });
            });
            
            metrics.push({
                label: 'Tasks Completed',
                value: totalCompleted.toString()
            });
            
            // Calculate best day
            let bestDay = 'Today';
            let bestScore = 0;
            
            if (habitData.user.dailyHistory) {
                for (const [date, data] of Object.entries(habitData.user.dailyHistory)) {
                    if (data.score > bestScore) {
                        bestScore = data.score;
                        bestDay = new Date(date).toLocaleDateString('en-US', { weekday: 'long' });
                    }
                }
            }
            
            metrics.push({
                label: 'Best Day',
                value: bestDay
            });
            
            // Add metrics to the container
            metrics.forEach(metric => {
                const metricEl = document.createElement('div');
                metricEl.className = 'analysis-metric';
                metricEl.innerHTML = `
                    <div class="metric-value">${metric.value}</div>
                    <div class="metric-label">${metric.label}</div>
                `;
                metricsContainer.appendChild(metricEl);
            });
        }

        function toggleCustomization() {
            if (customizationContent.style.display === 'grid') {
                customizationContent.style.display = 'none';
                customizationChevron.style.transform = 'rotate(0deg)';
            } else {
                customizationContent.style.display = 'grid';
                customizationChevron.style.transform = 'rotate(180deg)';
            }
        }

        // Connect exportDataBtn and importDataBtn to backup/restore functions
        document.addEventListener('DOMContentLoaded', function() {
            // Use the existing header buttons instead of creating duplicates
            const exportDataBtn = document.getElementById('exportDataBtn');
            const importDataBtn = document.getElementById('importDataBtn');
            
            if (exportDataBtn) {
                exportDataBtn.addEventListener('click', backupData);
            }
            
            if (importDataBtn) {
                importDataBtn.addEventListener('click', restoreData);
            }
        });

        // Last action tracking for undo functionality
        let lastAction = null;
        const undoButton = document.getElementById('undoButton');
        
        // Helper function to show the undo button
        function showUndoButton() {
            undoButton.classList.add('show');
            // Hide undo button after 10 seconds if not used
            setTimeout(() => {
                if (undoButton.classList.contains('show')) {
                    undoButton.classList.remove('show');
                }
            }, 10000);
        }
        
        // Helper function to track actions for undo
        function trackAction(type, data) {
            lastAction = {
                type: type,
                data: JSON.parse(JSON.stringify(data)), // Deep copy
                timestamp: Date.now()
            };
            showUndoButton();
        }
        
        // Undo the last action
        function undoLastAction() {
            if (!lastAction) {
                alert('Nothing to undo');
                return;
            }
            
            // Only allow undoing actions that are less than 30 seconds old
            const timeSinceAction = Date.now() - lastAction.timestamp;
            if (timeSinceAction > 30000) {
                alert('Can only undo actions performed in the last 30 seconds');
                undoButton.classList.remove('show');
                lastAction = null;
                return;
            }
            
            const { type, data } = lastAction;
            
            switch (type) {
                case 'addSubtask':
                    // Remove the last added subtask
                    const goalIndex = habitData.goals.findIndex(goal => goal.id === data.goalId);
                    if (goalIndex !== -1) {
                        const subtaskIndex = habitData.goals[goalIndex].subtasks.findIndex(
                            subtask => subtask.id === data.subtaskId
                        );
                        if (subtaskIndex !== -1) {
                            habitData.goals[goalIndex].subtasks.splice(subtaskIndex, 1);
                        }
                    }
                    break;
                    
                case 'deleteSubtask':
                    // Restore the deleted subtask
                    const gIndex = habitData.goals.findIndex(goal => goal.id === data.goalId);
                    if (gIndex !== -1) {
                        habitData.goals[gIndex].subtasks.push(data.subtask);
                    }
                    break;
                    
                case 'toggleSubtask':
                    // Revert the toggle
                    const gIdx = habitData.goals.findIndex(goal => goal.id === data.goalId);
                    if (gIdx !== -1) {
                        const sIdx = habitData.goals[gIdx].subtasks.findIndex(
                            subtask => subtask.id === data.subtaskId
                        );
                        if (sIdx !== -1) {
                            const currentState = habitData.goals[gIdx].subtasks[sIdx].completed;
                            habitData.goals[gIdx].subtasks[sIdx].completed = !currentState;
                            
                            // Also revert the points change
                            if (currentState) {
                                // Was completed, now uncompleted, subtract points
                                habitData.user.score -= data.points;
                            } else {
                                // Was uncompleted, now completed, add points
                                habitData.user.score += data.points;
                            }
                        }
                    }
                    break;
                    
                case 'addGoal':
                    // Remove the added goal
                    const goalIdx = habitData.goals.findIndex(goal => goal.id === data.goalId);
                    if (goalIdx !== -1) {
                        habitData.goals.splice(goalIdx, 1);
                    }
                    break;
                    
                case 'deleteGoal':
                    // Restore the deleted goal
                    habitData.goals.push(data.goal);
                    break;
                    
                default:
                    alert('Cannot undo this action');
                    break;
            }
            
            // Reset last action and hide undo button
            lastAction = null;
            undoButton.classList.remove('show');
            
            // Save and render
            saveData();
            renderGoals();
            updateLeaderboard();
            
            showToast('Action undone successfully');
        }
        
        // Connect undo button
        undoButton.addEventListener('click', undoLastAction);
    </script>
</body>
</html>
